{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mininterface Docs","text":""},{"location":"#run","title":"Run","text":""},{"location":"#mininterface.run","title":"<code>run(env_class=None, ask_on_empty_cli=False, title='', config_file=True, add_verbosity=True, ask_for_missing=True, interface=GuiInterface or TuiInterface, **kwargs)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>env_class</code> <code>Type[EnvClass] | None</code> <p>description, defaults to None  Tohle funguje p\u011bkn\u011b, \u017eejo?</p> <p>Raw</p> <pre><code>my_var = 1\n</code></pre> <code>None</code> <code>ask_on_empty_cli</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>title</code> <code>str</code> <p>description. Defaults to \"\".</p> <code>''</code> <code>config_file</code> <code>Path | str | bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>add_verbosity</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>ask_for_missing</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>interface</code> <code>Type[Mininterface]</code> <p>description. Defaults to GuiInterfaceorTuiInterface.</p> <code>GuiInterface or TuiInterface</code> <p>Returns:</p> Type Description <code>Mininterface[EnvClass]</code> <p>description</p> Source code in <code>mininterface/__init__.py</code> <pre><code>def run(env_class: Type[EnvClass] | None = None,\n        ask_on_empty_cli: bool = False,\n        title: str = \"\",\n        config_file: Path | str | bool = True,\n        add_verbosity: bool = True,\n        ask_for_missing: bool = True,\n        interface: Type[Mininterface] = GuiInterface or TuiInterface,\n        **kwargs) -&gt; Mininterface[EnvClass]:\n    \"\"\"_summary_\n\n    Args:\n        env_class: _description_, defaults to None\n            ![Image title](https://pypi-camo.freetls.fastly.net/c2fcccebbd5bf0af358057d752d67cee232fa866/68747470733a2f2f6769746875622e636f6d2f435a2d4e49432f6d696e696e746572666163652f626c6f622f6d61696e2f61737365742f68656c6c6f2d776f726c642e706e673f7261773d54727565)\n            Tohle funguje p\u011bkn\u011b, \u017eejo?\n\n            Raw\n\n            ```bash\n            my_var = 1\n            ```\n        ask_on_empty_cli: _description_. Defaults to False.\n        title: _description_. Defaults to \"\".\n        config_file: _description_. Defaults to True.\n        add_verbosity: _description_. Defaults to True.\n        ask_for_missing: _description_. Defaults to True.\n        interface: _description_. Defaults to GuiInterfaceorTuiInterface.\n\n    Returns:\n        _description_\n    \"\"\"\n    r\"\"\"_summary_\n\n\n    :param env_class: _description_, defaults to None\n        ![Image title](https://pypi-camo.freetls.fastly.net/c2fcccebbd5bf0af358057d752d67cee232fa866/68747470733a2f2f6769746875622e636f6d2f435a2d4e49432f6d696e696e746572666163652f626c6f622f6d61696e2f61737365742f68656c6c6f2d776f726c642e706e673f7261773d54727565)\n        Tohle funguje p\u011bkn\u011b, \u017eejo?\n\n        Raw\n\n        ```python\n        my_var = 1\n        ```\n    :param ask_on_empty_cli: _description_, defaults to False\n    :param title: _description_, defaults to \"\"\n    :param config_file: _description_, defaults to True\n    :param add_verbosity: _description_, defaults to True\n    :param ask_for_missing: _description_, defaults to True\n    :param interface: _description_, defaults to GuiInterfaceorTuiInterface\n    :return: _description_\n    \"\"\"\n    \"\"\" The main access, start here.\n    Wrap your configuration dataclass into `run` to access the interface. An interface is chosen automatically,\n    with the preference of the graphical one, regressed to a text interface for machines without display.\n    Besides, if given a configuration dataclass, the function enriches it with the CLI commands and possibly\n    with the default from a config file if such exists.\n    It searches the config file in the current working directory,\n    with the program name ending on *.yaml*, ex: `program.py` will fetch `./program.yaml`.\n\n    :param env_class: Dataclass with the configuration. Their values will be modified with the CLI arguments.\n    :param ask_on_empty_cli: If program was launched with no arguments (empty CLI), invokes self.form() to edit the fields.\n(Withdrawn when `ask_for_missing` happens.)\n```python\n@dataclass\nclass Env:\n  number: int = 3\n  text: str = \"\"\nm = run(Env, ask_on_empty=True)\n```\n\n```bash\n$ program.py  #  omitting all parameters\n# Dialog for `number` and `text` appears\n$ program.py --number 3\n# No dialog appears\n```\n    :param title: The main title. If not set, taken from `prog` or program name.\n    :param config_file: File to load YAML to be merged with the configuration.\n            You do not have to re-define all the settings in the config file, you can choose a few.\n            If set to True (default), we try to find one in the current working dir,\n            whose name stem is the same as the program's.\n            Ex: `program.py` will search for `program.yaml`.\n            If False, no config file is used.\n    :param add_verbosity: Adds the verbose flag that automatically sets the level to `logging.INFO` (*-v*) or `logging.DEBUG` (*-vv*).\n\n```python\nimport logging\nlogger = logging.getLogger(__name__)\n\nm = run(Env, add_verbosity=True)\nlogger.info(\"Info shown\") # needs `-v` or `--verbose`\nlogger.debug(\"Debug not shown\")  # needs `-vv`\n# $ program.py --verbose\n# Info shown\n```\n\n```bash\n$ program.py --verbose\nInfo shown\n```\n\n   :param ask_for_missing: If some required fields are missing at startup, we ask for them in a UI instead of program exit.\n\n```python\n@dataclass\nclass Env:\n  required_number: int\nm = run(Env, ask_for_missing=True)\n```\n\n```bash\n$ program.py  # omitting --required-number\n# Dialog for `required_number` appears\n```\n    :param interface: Which interface to prefer. By default, we use the GUI, the fallback is the TUI.\n    :param **kwargs The same as for [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html).\n    :return: An interface, ready to be used.\n\n    You cay context manager the function by a `with` statement.\n    The stdout will be redirected to the interface (ex. a GUI window).\n\n    Undocumented: The `env_class` may be a function as well. We invoke its parameters.\n    However, as Mininterface.env stores the output of the function instead of the Argparse namespace,\n    methods like `Mininterface.form(None)` (to ask for editing the env values) will work unpredictibly.\n    Also, the config file seems to be fetched only for positional (missing) parameters,\n    and ignored for keyword (filled) parameters.\n    It seems to be this is the tyro's deal and hence it might start working any time.\n    If not, we might help it this way:\n        `if isinstance(config, FunctionType): config = lambda: config(**kwargs[\"default\"])`\n\n    Undocumented: `default` keyword argument for tyro may serve for default values instead of a config file.\n    \"\"\"\n\n    # Prepare the config file\n    if config_file is True and not kwargs.get(\"default\") and env_class:\n        # Undocumented feature. User put a namespace into kwargs[\"default\"]\n        # that already serves for defaults. We do not fetch defaults yet from a config file.\n        cf = Path(sys.argv[0]).with_suffix(\".yaml\")\n        if cf.exists():\n            config_file = cf\n    if isinstance(config_file, bool):\n        config_file = None\n    elif isinstance(config_file, str):\n        config_file = Path(config_file)\n\n    # Load configuration from CLI and a config file\n    env, descriptions, wrong_fields = None, {}, {}\n    if env_class:\n        env, descriptions, wrong_fields = _parse_cli(env_class, config_file, add_verbosity, ask_for_missing, **kwargs)\n\n    # Build the interface\n    title = title or kwargs.get(\"prog\") or Path(sys.argv[0]).name\n    if \"prog\" not in kwargs:\n        kwargs[\"prog\"] = title\n    try:\n        interface = interface(title, env, descriptions)\n    except InterfaceNotAvailable:  # Fallback to a different interface\n        interface = TuiInterface(title, env, descriptions)\n\n    # Empty CLI \u2192 GUI edit\n    if ask_for_missing and wrong_fields:\n        # Some fields must be set.\n        interface.form(wrong_fields)\n        {setattr(interface.env, k, v.val) for k, v in wrong_fields.items()}\n    elif ask_on_empty_cli and len(sys.argv) &lt;= 1:\n        interface.form()\n\n    return interface\n</code></pre>"},{"location":"#mininterface_1","title":"Mininterface","text":"<p>               Bases: <code>Generic[EnvClass]</code></p> <p>The base interface. You get one through <code>mininterface.run</code> which fills CLI arguments and config file to <code>mininterface.env</code> or you can create it directly (without benefiting from the CLI parsing).</p> <p>This base interface does not require any user input and hence is suitable for headless testing.</p>"},{"location":"#mininterface.mininterface.Mininterface.env","title":"<code>env: EnvClass = _env or SimpleNamespace()</code>  <code>instance-attribute</code>","text":"<p>Parsed arguments, fetched from cli Contains whole configuration (previously fetched from CLI and config file).</p>"},{"location":"#mininterface.mininterface.Mininterface.__enter__","title":"<code>__enter__()</code>","text":"<p>When used in the with statement, the GUI window does not vanish between dialogs and it redirects the stdout to a text area.</p>"},{"location":"#mininterface.mininterface.Mininterface.alert","title":"<code>alert(text)</code>","text":"<p>Prompt the user to confirm the text.</p>"},{"location":"#mininterface.mininterface.Mininterface.ask","title":"<code>ask(text)</code>","text":"<p>Prompt the user to input a text.</p>"},{"location":"#mininterface.mininterface.Mininterface.ask_number","title":"<code>ask_number(text)</code>","text":"<p>Prompt the user to input a number. Empty input = 0.</p>"},{"location":"#mininterface.mininterface.Mininterface.form","title":"<code>form(form=None, title='')</code>","text":"<p>Prompt the user to fill up whole form. :param form: Dict of <code>{labels: default value}</code>. The form widget infers from the default value type.     The dict can be nested, it can contain a subgroup.     The default value might be <code>mininterface.Tag</code> that allows you to add descriptions.     If None, the <code>self.env</code> is being used as a form, allowing the user to edit whole configuration.         (Previously fetched from CLI and config file.)     A checkbox example: <code>{\"my label\": Tag(True, \"my description\")}</code> :param title: Optional form title</p>"},{"location":"#mininterface.mininterface.Mininterface.is_no","title":"<code>is_no(text)</code>","text":"<p>Display confirm box, focusing no.</p>"},{"location":"#mininterface.mininterface.Mininterface.is_yes","title":"<code>is_yes(text)</code>","text":"<p>Display confirm box, focusing yes.</p>"}]}