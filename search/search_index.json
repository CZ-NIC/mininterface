{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mininterface \u2013 access to GUI, TUI, web, CLI and config files","text":"<p>Write the program core, do not bother with the input/output.</p> <p> </p> <p>Check out the code, which is surprisingly short, that displays such a window or its textual fallback.</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    \"\"\" This calculates something. \"\"\"\n\n    my_flag: bool = False\n    \"\"\" This switches the functionality \"\"\"\n\n    my_number: int = 4\n    \"\"\" This number is very important \"\"\"\n\nif __name__ == \"__main__\":\n    m = run(Env, title=\"My application\")\n    m.form()\n    # Attributes are suggested by the IDE\n    # along with the hint text 'This number is very important'.\n    print(m.env.my_number)\n</code></pre>"},{"location":"#contents","title":"Contents","text":"<ul> <li>You got CLI</li> <li>You got config file management</li> <li>You got dialogs</li> <li>Background</li> <li>Installation</li> <li>Docs</li> <li>Gallery</li> <li>Examples<ul> <li>Hello world</li> <li>Goodbye argparse world</li> </ul> </li> </ul>"},{"location":"#you-got-cli","title":"You got CLI","text":"<p>It was all the code you need. No lengthy blocks of code imposed by an external dependency. Besides the GUI/TUI/web, you receive powerful YAML-configurable CLI parsing.</p> <pre><code>$ ./program.py --help\nusage: program.py [-h] [-v] [--my-flag | --no-my-flag] [--my-number INT]\n\nThis calculates something.\n\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help             show this help message and exit                  \u2502\n\u2502 -v, --verbose          Verbosity level. Can be used twice to increase.  \u2502\n\u2502 --my-flag, --no-my-flag                                                 \u2502\n\u2502                        This switches the functionality (default: False) \u2502\n\u2502 --my-number INT        This number is very important (default: 4)       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#you-got-config-file-management","title":"You got config file management","text":"<p>Loading config file is a piece of cake. Alongside <code>program.py</code>, write some of its arguments to <code>program.yaml</code>. They are seamlessly taken as defaults.</p> <pre><code>my_number: 555\n</code></pre> <pre><code>$ program.py --help\n...\n\u2502 --my-number INT        This number is very important (default: 555)     \u2502\n</code></pre>"},{"location":"#you-got-dialogs","title":"You got dialogs","text":"<p>Check out several useful methods to handle user dialogs. Here we bound the interface to a <code>with</code> statement that redirects stdout directly to the window.</p> <pre><code>with run(Env) as m:\n    print(f\"Your important number is {m.env.my_number}\")\n    boolean = m.confirm(\"Is that alright?\")\n</code></pre> <p> </p>"},{"location":"#background","title":"Background","text":"<p>Wrapper between various libraries that provide a user interface.</p> <p>Writing a small and useful program might be a task that takes fifteen minutes. Adding a CLI to specify the parameters is not so much overhead. But building a simple GUI around it? HOURS! Hours spent on researching GUI libraries, wondering why the Python desktop app ecosystem lags so far behind the web world. All you need is a few input fields validated through a clickable window... You do not deserve to add hundred of lines of the code just to define some editable fields. Mininterface is here to help.</p> <p>The config variables needed by your program are kept in cozy dataclasses. Write less! The syntax of tyro does not require any overhead (as its <code>argparse</code> alternatives do). You just annotate a class attribute, append a simple docstring and get a fully functional application:</p> <ul> <li>Call it as <code>program.py --help</code> to display full help.</li> <li>Use any flag in CLI: <code>program.py --my-flag</code>  causes <code>env.my_flag</code> be set to <code>True</code>.</li> <li>The main benefit: Launch it without parameters as <code>program.py</code> to get a fully working window with all the flags ready to be edited.</li> <li>Running on a remote machine? Automatic regression to the text interface.</li> <li>Or access your program via web browser.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install with a single command from PyPi.</p> <pre><code>pip install mininterface[all]  # GPLv3 and compatible\n</code></pre>"},{"location":"#bundles","title":"Bundles","text":"<p>There are various bundles. We mark the least permissive licence in the bundle.</p> bundle size licence description mininterface 1 MB LGPL minimal \u2013 only text dialogs mininterface[basic] 25 MB LGPL CLI, GUI, TUI mininterface[web] 40 MB LGPL including WebInterface mininterface[img] 40 MB LGPL images mininterface[tui] 40 MB LGPL images mininterface[gui] 70 MB GPL images, combobox, calendar mininterface[ui] 90 MB GPL full installation mininterface[all] 90 MB GPL full installation, same as <code>ui</code>, reserved for future use (big dependencies, optional interfaces) <p>Apart from the minimal bundle (which lacks CLI and dataclass support), they have the same functionality, differring only in the user experience.</p> <p>Tip</p> <p>For automated testing (e.g., in CI environments), the <code>mininterface[basic]</code> bundle is sufficient.</p>"},{"location":"#macos-gui","title":"MacOS GUI","text":"<p>If the GUI does not work on MacOS, you might need to launch: <code>brew install python-tk</code></p>"},{"location":"#docs","title":"Docs","text":"<p>See the docs overview at https://cz-nic.github.io/mininterface/.</p>"},{"location":"#gallery","title":"Gallery","text":"<p>These projects have the code base reduced thanks to the mininterface:</p> <ul> <li>deduplidog \u2013 Find duplicates in a scattered directory structure</li> <li>touch-timestamp \u2013 A powerful dialog to change the files' timestamp</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#hello-world","title":"Hello world","text":"<p>Take a look at the following example.</p> <ol> <li>We define any Env class.</li> <li>Then, we initialize mininterface with <code>run(Env)</code> \u2013 the missing fields will be prompter for</li> <li>Then, we use various dialog methods, like <code>confirm</code>, <code>choice</code> or <code>form</code>.</li> </ol> <p>Below, you find the screenshots how the program looks in various environments (graphic interface, web interface...).</p> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\nfrom mininterface import run\n\n@dataclass\nclass Env:\n  my_file: Path  # This is my help text\n  my_flag: bool = False\n  my_number: int = 4\n\nif __name__ == \"__main__\":\n    # Here, the user will be prompted\n    # for missing parameters (`my_file`) automatically\n    with run(Env) as m:\n\n      # You can lean on the typing\n      # Ex. directly read from the file object:\n      print(\"The file contents:\", m.env.my_file.read_text())\n\n      # You can use various dialog methods,\n      # like `confirm` for bool\n      if m.confirm(\"Do you want to continue?\"):\n\n        # or `choice` for choosing a value\n        fruit = m.select((\"apple\", \"banana\", \"sirup\"), \"Choose a fruit\")\n\n        if fruit == \"apple\":\n          # or `form` for an arbitrary values\n          m.form({\n            \"How many\": 0,\n            \"Choose another file\": m.env.my_file\n          })\n</code></pre> <p>Launch with <code>./program.py</code>:</p> <p> </p> <p>Or at the remote machine <code>MININTERFACE_INTERFACE=tui ./program.py</code>:</p> <p> </p> <p>Or via the plain text <code>MININTERFACE_INTERFACE=text ./program.py</code>:</p> <p></p> <p>Or via web browser <code>MININTERFACE_INTERFACE=web ./program.py</code>:</p> <p></p> <p>You can always set Env via CLI or a config file:</p> <pre><code>$ ./program.py --help\nusage: program.py [-h] [OPTIONS]\n\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help             show this help message and exit                 \u2502\n\u2502 -v, --verbose          Verbosity level. Can be used twice to increase. \u2502\n\u2502 --my-file PATH         This is my help text (required)                 \u2502\n\u2502 --my-flag, --no-my-flag                                                \u2502\n\u2502                        (default: False)                                \u2502\n\u2502 --my-number INT        (default: 4)                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#goodbye-argparse-world","title":"Goodbye argparse world","text":"<p>You want to try out the Mininterface with your current <code>ArgumentParser</code>?</p> <p>You're using positional arguments, subparsers, types in the ArgumentParser... Mininterface will give you immediate benefit. Just wrap it inside the <code>run</code> method.</p> <pre><code>#!/usr/bin/env python3\nfrom argparse import ArgumentParser\nfrom datetime import time\nfrom pathlib import Path\n\nfrom mininterface import run\n\nparser = ArgumentParser()\nparser.add_argument(\"input_file\", type=Path, help=\"Path to the input file.\")\nparser.add_argument(\"--time\", type=time, help=\"Given time\")\nsubparsers = parser.add_subparsers(dest=\"command\", required=True)\nsub1 = subparsers.add_parser(\"build\", help=\"Build something.\")\nsub1.add_argument(\"--optimize\", action=\"store_true\", help=\"Enable optimizations.\")\n\n# Old version\n# env = parser.parse_args()\n# env.input_file  # a Path object\n\n# New version\nm = run(parser)\nm.env.input_file  # a Path object\n\n# Live edit of the fields\nm.form()\n</code></pre> <p>Now, the help text looks much better. Try it in the terminal to see the colours.</p> <pre><code>$ ./program.py --help\nusage: program.py [-h] [OPTIONS] PATH\n\n\u256d\u2500 positional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 PATH                    Path to the input file. (required)              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help              show this help message and exit                 \u2502\n\u2502 -v, --verbose           Verbosity level. Can be used twice to increase. \u2502\n\u2502 --time HH:MM[:SS[\u2026]]    Given time (default: 00:00:00)                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 build options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --build.optimize, --build.no-optimize                                   \u2502\n\u2502                         Enable optimizations. (default: False)          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>And what happens when you launch the program? First, Mininterface asks you to provide the missing required arguments. Note the button to raise a file picker dialog.</p> <p></p> <p>Then, a <code>.form()</code> call will create a dialog with all the fields.</p> <p></p> <p>You will access the arguments through <code>m.env</code></p> <pre><code>print(m.env.time)  # -&gt; 14:21\n</code></pre> <p>If you're sure enough to start using Mininterface, convert the argparse into a dataclass. Then, the IDE will auto-complete the hints as you type.</p> <p>Warning</p> <p>Be aware that in contrast to the argparse, we create default values. This does make sense for most values but might pose a confusion for ex. <code>parser.add_argument(\"--path\", type=Path)</code> which becomes <code>Path('.')</code>, not <code>None</code>.</p>"},{"location":"CallbackTag/","title":"CallbackTag","text":""},{"location":"CallbackTag/#mininterface.tag.CallbackTag","title":"<code>mininterface.tag.CallbackTag</code>","text":"<p>Callback function is guaranteed to receive the Tag as a parameter.</p> <p>Warning</p> <p>Experimental. May change into a CallableTag.</p> <p>For the following examples, we will use these custom callback functions: <pre><code>from mininterface import run\n\ndef callback_raw():\n    \"\"\" Dummy function \"\"\"\n    print(\"Priting text\")\n    return 50\n\ndef callback_tag(tag: Tag):\n    \"\"\" Receives a tag \"\"\"\n    print(\"Printing\", type(tag))\n    return 100\n\nm = run()\n</code></pre></p> <p>Use as buttons in a form: <pre><code>m.form({\"Button\": callback_raw})\nm.form({\"Button\": CallbackTag(callback_tag)})\n</code></pre></p> <p></p> <p>Via form, we receive the function handler: <pre><code>out = m.form({\n    \"My choice\": Tag(options=[callback_raw, CallbackTag(callback_tag)])\n})\nprint(out)  # {'My choice': &lt;function callback_raw at 0x7ae5b3e74ea0&gt;}\n</code></pre></p> <p>Via choice, we receive the function output:</p> <pre><code>out = m.select({\n    \"My choice1\": callback_raw,\n    \"My choice2\": CallbackTag(callback_tag),\n    # Not supported: \"My choice3\": Tag(callback_tag, annotation=CallbackTag),\n})\nprint(out)  # output of callback0 or callback_tag, ex:\n#    Printing &lt;class 'mininterface.tag.CallbackTag'&gt;\n#    100\n</code></pre> <p></p> <p>You may use callback in a dataclass. <pre><code>@dataclass\nclass Callbacks:\n    p1: Callable = callback0\n    p2: Annotated[Callable, CallbackTag(description=\"Foo\")] = callback_tag\n    # Not supported: p3: CallbackTag = callback_tag\n    # Not supported: p4: CallbackTag = field(default_factory=CallbackTag(callback_tag))\n    # Not supported: p5: Annotated[Callable, Tag(description=\"Bar\", annotation=CallbackTag)] = callback_tag\n\nm = run(Callbacks)\nm.form()\n</code></pre></p>"},{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#100-2025-05-08","title":"1.0.0 (2025-05-08)","text":"<ul> <li>CHANGED \u2013 renamed: API is becoming stable but we have to rename several things.<ul> <li>.is_yes -&gt; Mininterface.confirm</li> <li>.is_no -&gt; .confirm(..., False) (because .is_no was counterintuitive)</li> <li>.choice -&gt; Mininterface.select (as HTML counterpart)</li> <li>EnumTag(choices=) -&gt; SelectTag(options=)</li> <li>Choices alias -&gt; Options alias</li> <li>MininterfaceOptions -&gt; MininterfaceSettings (to not meddle with the SelectTag)</li> <li>mininterface.types.rich_tags -&gt; mininterface.tag.*</li> <li>Tag attribute order, swap <code>name</code> and <code>validation</code></li> <li>.ask_number -&gt; Mininterface.ask(..., int)</li> <li>Mininterface.ask does not return None anymore but forces the type</li> <li>Tag.name -&gt; Tag.label</li> <li>removed <code>--integrate-to-system</code> in favour of <code>mininterface integrate</code></li> <li>.subcommands -&gt; mininterface.cli</li> </ul> </li> <li>WebInterface</li> <li>SelectTag(multiple=)</li> <li>argparse support</li> <li>minimal bundle</li> <li>file picker</li> <li>fix: TkInterface focus and tab navigation</li> </ul>"},{"location":"Changelog/#080-2025-04-01","title":"0.8.0 (2025-04-01)","text":"<ul> <li>CHANGED: EnumTag instead of Tag(choices=)</li> <li>WebInterface (working draft)</li> <li>much better TextInterface</li> <li>SecretTag</li> <li>PathTag UI in TextualInterface</li> <li>UI options available from the program</li> <li>Mininterface.choice tips parameter</li> <li>better annotated fetching</li> </ul>"},{"location":"Changelog/#075-2025-01-29","title":"0.7.5 (2025-01-29)","text":"<ul> <li>UI options</li> <li>experimental Facet._layout</li> </ul>"},{"location":"Changelog/#074-2025-01-27","title":"0.7.4 (2025-01-27)","text":"<ul> <li>Python 3.13 compatible</li> <li>emits a warning when for config file fields, unknown to the model</li> </ul>"},{"location":"Changelog/#073-2025-01-09","title":"0.7.3 (2025-01-09)","text":"<ul> <li>fix: put GUI descriptions back to the bottom</li> </ul>"},{"location":"Changelog/#072-2024-12-30","title":"0.7.2 (2024-12-30)","text":"<ul> <li>GUI calendar</li> </ul>"},{"location":"Changelog/#071-2024-11-27","title":"0.7.1 (2024-11-27)","text":"<ul> <li>GUI scrollbars if window is bigger than the screen</li> <li>non-interactive session support</li> <li>datetime support</li> <li>nested generics support (a tuple in a list)</li> </ul>"},{"location":"Changelog/#070-2024-11-08","title":"0.7.0 (2024-11-08)","text":"<ul> <li>hidden <code>--integrate-to-system</code> argument</li> <li>interfaces migrated to <code>mininterface.interfaces</code> to save around 50 ms starting time due to lazy loading</li> <li>SubcommandPlaceholder</li> </ul>"},{"location":"Cli/","title":"Cli","text":""},{"location":"Cli/#mininterface.cli","title":"<code>mininterface.cli</code>","text":"<p>Useful objects meaningful for CLI handling only.</p>"},{"location":"Cli/#mininterface.cli.Positional","title":"<code>Positional = Positional</code>","text":"<p>Annotate the dataclass field with <code>Positional</code> to make it behave like a positional argument in the CLI.</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\nfrom mininterface.cli import Positional\n\n@dataclass\nclass Env:\n    flag1: Positional[str] = \"default\"\n    flag2: str = \"flag\"\n\nrun(Env)\n</code></pre> <pre><code>$ ./program.py --help\nusage: program.py [-h] [-v] [--flag2 STR] [STR]\n\n\u256d\u2500 positional arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 [STR]                flag1 (default: default)                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help           show this help message and exit                 \u2502\n\u2502 -v, --verbose        Verbosity level. Can be used twice to increase. \u2502\n\u2502 --flag2 STR          (default: flag)                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>This is just a link from <code>tyro.conf</code> package which comes bundled. You will find much more useful features there. https://brentyi.github.io/tyro/api/tyro/conf/#tyro.conf.Positional</p>"},{"location":"Cli/#mininterface.cli.Command","title":"<code>Command</code>","text":"<p>The Command is automatically run while instantanied.</p> <p>It adapts <code>init</code> and <code>run</code> methods. It receives attributes <code>self.facet</code> and <code>self.interface</code> set.</p> <p>Put list of Commands to the mininterface.run and divide your application into different sections. Alternative to argparse subcommands.</p> <p>Commands might inherit from the same parent to share the common attributes.</p>"},{"location":"Cli/#mininterface.cli.Command--subcommandplaceholder-class","title":"SubcommandPlaceholder class","text":"<p>The special class <code>SubcommandPlaceholder</code> let the user to choose the subcommands via UI, while still benefiting from the default CLI arguments.</p>"},{"location":"Cli/#mininterface.cli.Command--the-cli-behaviour","title":"The CLI behaviour:","text":"<ul> <li><code>./program.py</code> -&gt; UI started with subcommand choice</li> <li><code>./program.py subcommand --flag</code> -&gt; special class <code>SubcommandPlaceholder</code> allows defining a common <code>--flag</code>     while still starting UI with subcommand choice</li> <li><code>./program.py subcommand1 --flag</code> -&gt; program run</li> <li><code>./program.py subcommand1</code> -&gt; fails to CLI for now</li> </ul>"},{"location":"Cli/#mininterface.cli.Command--an-example-of-command-usage","title":"An example of Command usage","text":"<pre><code>from dataclasses import dataclass, field\nfrom pathlib import Path\nfrom mininterface import run\nfrom mininterface.exceptions import ValidationFail\nfrom mininterface.cli import Command, SubcommandPlaceholder\nfrom tyro.conf import Positional\n\n\n@dataclass\nclass SharedArgs(Command):\n    common: int\n    files: Positional[list[Path]] = field(default_factory=list)\n\n    def init(self):\n        self.internal = \"value\"\n\n\n@dataclass\nclass Subcommand1(SharedArgs):\n    my_local: int = 1\n\n    def run(self):\n        print(\"Common:\", self.common)  # user input\n        print(\"Number:\", self.my_local)  # 1 or user input\n        print(\"Internal:\", self.internal)\n        raise ValidationFail(\"The submit button blocked!\")\n\n\n@dataclass\nclass Subcommand2(SharedArgs):\n    def run(self):\n        self.facet.set_title(\"Button clicked\")  # you can access internal self.facet: Facet\n        print(\"Common files\", self.files)\n\n\nm = run([Subcommand1, Subcommand2, SubcommandPlaceholder])\nm.alert(\"App continue\")\n</code></pre> <p>Let's start the program, passing there common flags, all HTML files in a folder and setting <code>--common</code> to 7. <pre><code>$ program.py subcommand *.html  --common 7\n</code></pre></p> <p></p> <p>As you see, thanks to <code>SubcommandPlaceholder</code>, subcommand was not chosen yet. Click to the first button.</p> <p></p> <p>and the terminal got:</p> <pre><code>Common: 7\nNumber: 1\nInternal: value\n</code></pre> <p>Click to the second button.</p> <p></p> <p>Terminal output: <pre><code>Common files [PosixPath('page1.html'), PosixPath('page2.html')]\n</code></pre></p>"},{"location":"Cli/#mininterface.cli.Command--powerful-automation","title":"Powerful automation","text":"<p>Note we use <code>from tyro.conf import Positional</code> to denote the positional argument. We did not have to write <code>--files</code> to put there HTML files.</p>"},{"location":"Cli/#mininterface.cli.Command.init","title":"<code>init()</code>","text":"<p>Just before the form appears. As the <code>__post_init__</code> method is not guaranteed to run just once (internal CLI behaviour), you are welcome to override this method instead. You can use self.facet from within.</p>"},{"location":"Cli/#mininterface.cli.Command.run","title":"<code>run()</code>","text":"<p>This method is run automatically when the command is chosen. (Either directly in the CLI or by a successive dialog.)</p> <p>Raises:</p> Type Description <code>ValidationFail</code> <p>Do repeat the form.</p>"},{"location":"Cli/#mininterface.cli.SubcommandPlaceholder","title":"<code>SubcommandPlaceholder</code>","text":"<p>Use this placeholder to choose the subcommand via a UI.</p>"},{"location":"DatetimeTag/","title":"DatetimeTag","text":""},{"location":"DatetimeTag/#mininterface.tag.DatetimeTag","title":"<code>mininterface.tag.DatetimeTag</code>","text":"<p>Datetime, date and time types are supported.</p> <pre><code>from datetime import datetime\nfrom dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    my_date: datetime\n\nm = run(Env)\n</code></pre> <p>The arrows change the day (or the datetime part the keyboard caret is currently editing).</p> <p></p> <p>In this code, we want only the date part.</p> <pre><code>from datetime import date\nfrom dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    my_date: date\n\nm = run(Env)\n</code></pre> <p>After clicking the button (or hitting <code>Ctrl+Shift+C</code>), a calendar appear.</p> <p></p>"},{"location":"DatetimeTag/#mininterface.tag.DatetimeTag.date","title":"<code>date: bool = False</code>","text":"<p>The date part is active. True for datetime and date.</p>"},{"location":"DatetimeTag/#mininterface.tag.DatetimeTag.time","title":"<code>time: bool = False</code>","text":"<p>The time part is active. True for datetime and time.</p>"},{"location":"DatetimeTag/#mininterface.tag.DatetimeTag.full_precision","title":"<code>full_precision: bool = False</code>","text":"<p>Include full time precison, seconds, microseconds.</p>"},{"location":"Dev-guide/","title":"Dev Guide","text":""},{"location":"Dev-guide/#new-features","title":"New features","text":"<p>All pull requests are welcome. Let's make script creation a better experience together. Alongside code base change, modify:</p> <ul> <li>CHANGELOG.md</li> <li>increase version in pyproject.toml</li> </ul> <p>If adding a dependency, make sure to reflect that in pyproject.toml and in README.md install section.</p>"},{"location":"Dev-guide/#interface-architecture","title":"Interface architecture","text":"<p>Every interface has several uniform objects:</p> <ul> <li>Mininterface: front-end for the programmer. Easy to use and uniform methods.</li> <li>Adaptor: Connection point. Public attributes not meant to be used by the (end-user) programmer.</li> <li>App (optional): External library UI handler. (Like tkinter.)</li> <li>Facet: Layout definition.</li> </ul> <pre><code>graph LR\ndataclass --&gt; Tags --&gt; Mininterface --&gt; Adaptor --&gt; App\nAdaptor --&gt; Facet\nFacet --&gt; Tags\n</code></pre> <p>Programmer uses a value -&gt; which is converted to Tag -&gt; which is converted to a widget by an interface Adaptor.</p>"},{"location":"Dev-guide/#adaptor","title":"Adaptor","text":""},{"location":"Dev-guide/#mininterface._mininterface.adaptor.BackendAdaptor","title":"<code>mininterface._mininterface.adaptor.BackendAdaptor</code>","text":"<p>Connection point between a Mininterface and an external UI library.</p>"},{"location":"Dev-guide/#mininterface._mininterface.adaptor.BackendAdaptor.widgetize","title":"<code>widgetize(tag)</code>","text":"<p>Wrap Tag to a UI widget.</p>"},{"location":"Dev-guide/#mininterface._mininterface.adaptor.BackendAdaptor.run_dialog","title":"<code>run_dialog(form, title='', submit=True)</code>","text":"<p>Let the user edit the dict values.</p> <p>Setups the facet._fetch_from_adaptor.</p>"},{"location":"Examples/","title":"Examples","text":"<p>A powerful <code>m.form</code> dialog method accepts either a dataclass or a dict. Take a look on both.</p>"},{"location":"Examples/#a-complex-dataclass","title":"A complex dataclass.","text":"<pre><code>from typing import Annotated\nfrom dataclasses import dataclass\nfrom mininterface.validators import not_empty\nfrom mininterface import run, Tag, Validation\n\n@dataclass\nclass NestedEnv:\n  another_number: int = 7\n  \"\"\" This field is nested \"\"\"\n\n@dataclass\nclass Env:\n  nested_config: NestedEnv\n\n  mandatory_str: str\n  \"\"\" As there is no default value, you will be prompted automatically to fill up the field \"\"\"\n\n  my_number: int | None = None\n  \"\"\" This is not just a dummy number, if left empty, it is None. \"\"\"\n\n  my_string: str = \"Hello\"\n  \"\"\" A dummy string \"\"\"\n\n  my_flag: bool = False\n  \"\"\" Checkbox test \"\"\"\n\n  my_validated: Annotated[str, Validation(not_empty)] = \"hello\"\n  \"\"\" A validated field \"\"\"\n\nm = run(Env, title=\"My program\")\n# See some values\nprint(m.env.nested_config.another_number)  # 7\nprint(m.env)\n# Env(nested_config=NestedEnv(another_number=7), my_number=5, my_string='Hello', my_flag=False, my_validated='hello')\n\n# Edit values in a dialog\nm.form()\n</code></pre> <p>As the attribute <code>mandatory_str</code> requires a value, a prompt appears automatically:</p> <p></p> <p>Then, full form appears:</p> <p></p>"},{"location":"Examples/#form-with-paths","title":"Form with paths","text":"<p>We have a dict with some paths. Here is how it looks.</p> <pre><code>from pathlib import Path\nfrom mininterface import run, Tag\n\nm = run(title=\"My program\")\nmy_dictionary = {\n  \"paths\": Tag(\"\", annotation=list[Path]),\n  \"default_paths\": Tag([Path(\"/tmp\"), Path(\"/usr\")], annotation=list[Path])\n  }\n\n# Edit values in a dialog\nm.form(my_dictionary)\n</code></pre> <p></p>"},{"location":"Exceptions/","title":"Exceptions","text":""},{"location":"Exceptions/#mininterface.exceptions","title":"<code>mininterface.exceptions</code>","text":"<p>Exceptions that might make sense to be used outside the library.</p>"},{"location":"Exceptions/#mininterface.exceptions.Cancelled","title":"<code>Cancelled</code>","text":"<p>User has cancelled. A SystemExit based exception noting that the program exits without a traceback, ex. if user hits the escape or closes the window.</p>"},{"location":"Exceptions/#mininterface.exceptions.ValidationFail","title":"<code>ValidationFail</code>","text":"<p>Signal to the form that submit failed and we want to restore it.</p>"},{"location":"Exceptions/#mininterface.exceptions.InterfaceNotAvailable","title":"<code>InterfaceNotAvailable</code>","text":"<p>Interface failed to init, ex. display not available in GUI. Or an underlying dependency was uninstalled.</p>"},{"location":"Exceptions/#mininterface.exceptions.DependencyRequired","title":"<code>DependencyRequired</code>","text":""},{"location":"Exceptions/#mininterface.exceptions.DependencyRequired.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>This is an elagant way to handling missing functions. Consider this case.</p> <pre><code>try:\n    from .._lib.cli_parser import parse_cli\nexcept DependencyRequired as e:\n    parse_cli = e\n</code></pre> <p>When the function is used, the original exception is raised.</p>"},{"location":"Exceptions/#mininterface.exceptions.DependencyRequired.exit","title":"<code>exit()</code>","text":"<p>Wrap the exception in a SystemExit so that the program exits without a traceback.</p>"},{"location":"Experimental/","title":"Experimental","text":""},{"location":"Experimental/#mininterface.experimental","title":"<code>mininterface.experimental</code>","text":""},{"location":"Experimental/#mininterface.experimental.SubmitButton","title":"<code>SubmitButton</code>","text":"<p>Create a button. When clicked, the form submits.         If submission succeeds (validation checks pass), its value becomes True.</p> <pre><code>from pathlib import Path\nfrom mininterface import run, Tag\nfrom mininterface.experimental import SubmitButton\n\nm = run()\nout = m.form({\n    \"File name\": Tag(\"/tmp\", annotation=Path),\n    \"Append text\": {\n        \"My text\": \"\",\n        \"Append now\": SubmitButton()\n    },\n    \"Duplicate\": {\n        \"Method\": Tag(\"twice\", options=[\"twice\", \"thrice\"]),\n        \"Duplicate now\": SubmitButton()\n    }\n})\n# Clicking on 'Append now' button\nprint(out)\n# {'File name': PosixPath('/tmp'),\n# 'Append text': {'My text': '', 'Append now': True},\n# 'Duplicate': {'Method': 'twice', 'Duplicate now': False}}\n</code></pre> <p></p>"},{"location":"Facet/","title":"Facet","text":""},{"location":"Facet/#mininterface.facet.Facet","title":"<code>mininterface.facet.Facet</code>","text":"<p>A frontend side of the interface. While a dialog is open,     this allows to set frontend properties like the heading.</p> <p>Read <code>Tag.facet</code> to see how to access it from the front-end side. Read <code>Mininterface.facet</code> to see how to access it from the back-end side.</p>"},{"location":"Facet/#mininterface.facet.Facet.set_title","title":"<code>set_title(text)</code>","text":"<p>Set the main heading.</p>"},{"location":"Facet/#mininterface.facet.Facet.submit","title":"<code>submit(_post_submit=None)</code>","text":"<p>Submits the whole form.</p> <pre><code>from mininterface import run, Tag\n\ndef callback(tag: Tag):\n    tag.facet.submit()\n\nm = run()\nout = m.form({\n    \"My choice\": Tag(options=[\"one\", \"two\"], on_change=callback)\n})\n# continue here immediately after clicking on a radio button\n</code></pre>"},{"location":"Facet/#layout","title":"Layout","text":"<p>Experimental</p> <p>Share your thoughs about how the layout method should work!</p> <p>Should you need represent more information, Facet has a hidden method <code>_layout</code> that you may call with a list of <code>LayoutElements</code>:</p> <ul> <li><code>str</code></li> <li><code>pathlib.Path</code></li> <li><code>facet.Image</code></li> </ul> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\nfrom mininterface import run\nfrom mininterface.facet import Image\n\n@dataclass\nclass Env:\n    my_str: str = \"Hello\"\n\nm = run(Env)\n# Image object has currently single 'src' attribute\nm.facet._layout([\"My text\", Image(\"dog1.jpg\"), Path(\"dog1.jpg\")])\nm.form()\n</code></pre> <p>As you see, the program displays \"My text\", then the image and than the path info. </p> <p>Even in the TUI, the images are visible. (And mouse-zoomable.) </p>"},{"location":"Helper-types/","title":"Helper types","text":""},{"location":"Helper-types/#mininterface.tag.tag.ErrorMessage","title":"<code>ErrorMessage = TypeVar('ErrorMessage')</code>","text":"<p>A string, callback validation error message.</p>"},{"location":"Helper-types/#mininterface.tag.tag.TagValue","title":"<code>TagValue = TypeVar('TagValue', bound=Any)</code>","text":"<p>Any value. It is being wrapped by a Tag.</p>"},{"location":"Helper-types/#mininterface.tag.tag.UiValue","title":"<code>UiValue = TagValue | str</code>","text":"<p>Candidate for the TagValue. Produced by the UI. Might be of the same type as the target TagValue, or str (as the default input type for interfaces that do not implement the given type further).</p>"},{"location":"Helper-types/#mininterface.tag.tag.ValidationCallback","title":"<code>ValidationCallback = Callable[['Tag'], ValidationResult | tuple[ValidationResult, TagValue]] | BaseMetadata | GroupedMetadata</code>","text":"<p>Being used at Tag.validation.</p> <p>Either use a custom callback function, a provided validator, or an annotated-types predicate. (You can use multiple validation callbacks combined into an itarable.)</p> <p>ValidationResult is a bool or the error message that implicitly means it has failed. Optionally, you may add a second argument to specify the tag value (to ex. recommend a better value).</p>"},{"location":"Helper-types/#mininterface.tag.tag.ValidationCallback--custom-function","title":"Custom function","text":"<p>Handles the Tag.</p> <pre><code>from mininterface.tag import Tag\n\ndef my_validation(tag: Tag):\n    return tag.val &gt; 50\n\nm.form({\"number\", Tag(\"\", validation=my_validation)})\n</code></pre>"},{"location":"Helper-types/#mininterface.tag.tag.ValidationCallback--provided-validators","title":"Provided validators","text":"<p>Found in the mininterface.validators module.</p> <pre><code>from mininterface.validators import not_empty\nm.form({\"number\", Tag(\"\", validation=not_empty)})\n# User cannot leave the field empty.\n</code></pre> <p>You may use the validation in a type annotation. <pre><code>from mininterface import Tag, Validation\n@dataclass\nclass Env:\n    my_text: Annotated[str, Validation(not_empty)] = \"will not be emtpy\"\n\n    # which is an alias for:\n    # my_text: Annotated[str, Tag(validation=not_empty)] = \"will not be emtpy\"\n</code></pre></p>"},{"location":"Helper-types/#mininterface.tag.tag.ValidationCallback--annotated-types-predicate","title":"annotated-types predicate.","text":"<p>The annotated-types are de-facto standard for types restraining.</p> <p>Currently, <code>Gt, Ge, Lt, Le, MultipleOf and Len</code> are supported.</p> <pre><code>from dataclasses import dataclass\nfrom annotated_types import Ge\nfrom mininterface import run\n\n@dataclass\nclass AnnotatedTypes:\n    age: Annotated[int, Ge(18)]\n\nrun(AnnotatedTypes).env.age  # guaranteed to be &gt;= 18\n</code></pre> <p>Info</p> <p>The annotated-types from the Annotated are prepended to the Tag(validation=) iterable.</p> <pre><code>@dataclass\nclass AnnotatedTypes:\n    age: Annotated[int, Ge(18), Tag(validation=custom)]\n\n# -&gt; age: Annotated[int, Tag(validation=[Ge(18), custom])]\n</code></pre>"},{"location":"Helper-types/#mininterface.tag.tag.ValidationResult","title":"<code>ValidationResult = bool | ErrorMessage</code>","text":"<p>Being used at Tag.validation.</p> <p>A bool or the error message (that implicitly means the ValidationCallback has failed) as shows the following table. Optionally, you may add a second argument to specify the tag value (to ex. recommend a better value).</p> return description bool True if validation succeeded or False if validation failed. str Error message if the validation failed. tuple[bool|str, TagVal] The first argument is the same as above. The second is the value to be set. <p>This example shows the str error message:</p> <pre><code>def check(tag: Tag):\n    if tag.val &lt; 10:\n        return \"The value must be at least 10\"\nm.form({\"number\", Tag(12, validation=check)})\n</code></pre> <p>This example shows the value transformation. For <code>val=50+</code>, the validation fails.</p> <pre><code>def check(tag: Tag):\n    return True, tag.val * 2\nm.form({\"number\", Tag(12, validation=(check, Lt(100)))})\n</code></pre>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType","title":"<code>OptionsType = list[TagValue] | tuple[TagValue, ...] | set[TagValue] | dict[RichOptionLabel, TagValue] | Iterable[Enum] | Type[Enum]</code>","text":"<p>You can denote the options in many ways. Either put options in an iterable or to a dict <code>{labels: value}</code>. Values might be Tags as well. Let's take a detailed look. We will use the <code>run.select(OptionsType)</code> to illustrate the examples.</p>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--iterables-like-list","title":"Iterables like list","text":"<p>Either put options in an iterable:</p> <pre><code>from mininterface import run\nm = run()\nm.select([1, 2])\n</code></pre> <p></p>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--dict-for-labels","title":"Dict for labels","text":"<p>Or to a dict <code>{name: value}</code>. Then name are used as labels.</p> <pre><code>m.select({\"one\": 1, \"two\": 2})  # returns 1\n</code></pre>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--dict-with-tuples-for-table","title":"Dict with tuples for table","text":"<p>If you use tuple as the keys, they will be joined into a table.</p> <pre><code>m.select({(\"one\", \"two\", \"three\"): 1, (\"lorem\", \"ipsum\", \"dolor\") : 2})\n</code></pre> <p></p>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--tags-for-labels","title":"Tags for labels","text":"<p>Alternatively, you may specify the names in <code>Tags</code>.</p> <pre><code>m.select([Tag(1, name=\"one\"), Tag(2, name=\"two\")])  # returns 1\n</code></pre> <p></p>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--enums","title":"Enums","text":"<p>Alternatively, you may use an Enum.</p> <pre><code>class Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\nm.select(Color)\n</code></pre> <p></p> <p>Alternatively, you may use an Enum instance. (Which means the default value is already selected.)</p> <pre><code>class Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\nm.select(Color.BLUE)\n</code></pre> <p></p> <p>Alternatively, you may use an Enum instances list.</p> <pre><code>m.select([Color.GREEN, Color.BLUE])\n</code></pre> <p></p>"},{"location":"Helper-types/#mininterface.tag.select_tag.OptionsType--further-examples","title":"Further examples","text":"<p>See mininterface.select or <code>SelectTag.options</code> for further usage.</p>"},{"location":"Helper-types/#mininterface._lib.form_dict.DataClass","title":"<code>DataClass = TypeVar('DataClass')</code>","text":"<p>Any dataclass. Or a pydantic model or attrs.</p>"},{"location":"Helper-types/#mininterface._lib.form_dict.EnvClass","title":"<code>EnvClass = TypeVar('EnvClass', bound=DataClass)</code>","text":"<p>Any dataclass. Its instance will be available through Mininterface.env after CLI parsing. Its fields or whole class might be annotated with tyro conf flags.</p> <p>The following example turns down boolean flag conversion.</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\nfrom tyro.conf import FlagConversionOff\n\n@dataclass\nclass Env:\n    my_bool: bool = False\n\nm = run(FlagConversionOff[Env])\n</code></pre> <pre><code>$ program.py --help\n# --my-bool {True,False}  (default: False)\n</code></pre> <p>Whereas by default, both flags are generated:</p> <pre><code>m = run(Env)\n</code></pre> <pre><code>$ program.py --help\n# --my-bool, --no-my-bool (default: False)\n</code></pre>"},{"location":"Helper-types/#mininterface._lib.form_dict.FormDict","title":"<code>FormDict = dict[Hashable, TypeVar('FormDictRecursiveValue', TagValue, Tag, 'Self')]</code>","text":"<p>Nested dict that can have descriptions (through Tag) instead of plain values.</p>"},{"location":"Helper-types/#mininterface.interfaces.InterfaceType","title":"<code>mininterface.interfaces.InterfaceType = Type[Mininterface] | InterfaceName | None</code>","text":"<p>Either a class symbol or a shortcut string.</p>"},{"location":"Interfaces/","title":"Interfaces","text":""},{"location":"Interfaces/#all-possible-interfaces","title":"All possible interfaces","text":"<p>Apart from the default <code>Mininterface</code>, the base interface the others are fully compatible with, several interfaces exist at <code>mininterface.interfaces</code>.</p> shortcut full name min Mininterface gui GuiInterface | TkInterface tui | textual TuiInterface text | tui TextInterface web WebInterface"},{"location":"Interfaces/#ordering","title":"Ordering","text":"<p>We try to obtain the best interface available. By preference, it is gui , then &gt; tui (textual or at least &gt; text), then the original non-interactive &gt; Mininterface is used. The ensures the program to still work in cron jobs etc.</p>"},{"location":"Interfaces/#getting-one","title":"Getting one","text":"<p>Normally, you get an interface through mininterface.run but if you do not wish to parse CLI and config file, you can invoke one directly through <code>from mininterface.interfaces import *</code>. You may as well use the <code>get_interface</code> function to ensure the interface is available or invoke the program with <code>MININTERFACE_INTERFACE</code> environment variable.</p> <p>Info</p> <p>Performance boost: Only interfaces that are being used are loaded into memory for faster start.</p>"},{"location":"Interfaces/#direct-invocation","title":"Direct invocation","text":"<p>How to invoke a specific interface directly?</p> <pre><code>from mininterface.interfaces import TuiInterface\n\nwith TuiInterface(\"My program\") as m:\n    number = m.ask(\"Returns number\", int)\n</code></pre>"},{"location":"Interfaces/#mininterface.interfaces.get_interface","title":"<code>get_interface</code>","text":"<p>Returns the best available interface.</p> <p>Similar to mininterface.run but without CLI or config file parsing.</p> <pre><code>from mininterface.interfaces import get_interface\nm = get_interface()\nm.ask(\"...\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>InterfaceType</code> <p>An interface type of preference.</p> <code>None</code> <code>title</code> <code>str</code> <p>Window title</p> <code>''</code> <code>settings</code> <code>Optional[MininterfaceSettings]</code> <p>MininterfaceSettings objects</p> <code>None</code> <code>env</code> <code>Optional[EnvClass]</code> <p>You can specify the .env attribute of the returned object.</p> <code>None</code>"},{"location":"Interfaces/#environment-variable-mininterface_interface","title":"Environment variable <code>MININTERFACE_INTERFACE</code>","text":"<p>From outside, you may override the default interface choice by the environment variable.</p> <p><code>$ MININTERFACE_INTERFACE=web program.py</code></p>"},{"location":"Interfaces/#mininterface","title":"<code>Mininterface</code>","text":"<p>The base interface.</p>"},{"location":"Interfaces/#guiinterface-or-tkinterface-or-gui","title":"<code>GuiInterface</code> or <code>TkInterface</code> or 'gui'","text":"<p>A tkinter window. It inherits from <code>GuiSettings</code>.</p> <pre><code>$ MININTERFACE_INTERFACE=gui ./program.py\n</code></pre> <p> The code for generating screenshots is taken from the Introduction.</p>"},{"location":"Interfaces/#tuiinterface-or-tui","title":"<code>TuiInterface</code> or 'tui'","text":"<p>An interactive terminal. Will try to get <code>TextualInterface</code> and <code>TextInterface</code> as a fallback.</p>"},{"location":"Interfaces/#textualinterface","title":"<code>TextualInterface</code>","text":"<p>If textual installed, rich and mouse clickable interface is used.</p> <pre><code>$ MININTERFACE_INTERFACE=tui ./program.py\n</code></pre> <p></p>"},{"location":"Interfaces/#textinterface","title":"<code>TextInterface</code>","text":"<p>Plain text only interface with no dependency as a fallback. The non-interactive session becomes interactive if possible but there is no mouse support. Does not clear whole screen as TextualInterface if it suits better your program flow.</p> <p><pre><code>$ MININTERFACE_INTERFACE=text ./program.py\n</code></pre> </p>"},{"location":"Interfaces/#webinterface-or-web","title":"<code>WebInterface</code> or 'web'","text":"<p>Exposed to a web.</p> <p>You can expose any script to the web by invoking it through the bundled <code>mininterface</code> program.</p> <pre><code>$ mininterface web ./program.py --port 9997\n</code></pre> <p>But still, you have the possibility to invoke the web by preference in the <code>run</code> or <code>get_interface</code> method, direct invocation through importing <code>WebInterface</code> from <code>mininterface.interfaces</code>, or through the environment variable.</p> <p><pre><code>$ MININTERFACE_INTERFACE=web ./program.py\nServing './program.py' on http://localhost:64646\n\nPress Ctrl+C to quit\n</code></pre> </p> <p>Caveat</p> <p>Should you plan to use the WebInterface, we recommend invoking it be the first thing your program do. All the statements before invoking it run multiple times!</p> <pre><code>hello = \"world\"  # This line would run thrice!\nwith run(interface=\"web\") as m:\n    m.form({\"one\": 1})\n    m.form({\"two\": 2})\n</code></pre> <p>Warning</p> <p>Still in beta. We appreciate help with testing etc.</p>"},{"location":"Interfaces/#replinterface","title":"<code>ReplInterface</code>","text":"<p>A debug terminal. Invokes a breakpoint after every dialog.</p>"},{"location":"Mininterface/","title":"Mininterface","text":""},{"location":"Mininterface/#mininterface.Mininterface","title":"<code>mininterface.Mininterface</code>","text":"<p>The base interface.     You get one through <code>mininterface.run</code> which fills CLI arguments and config file to <code>mininterface.env</code>     or you can create one directly (without benefiting from the CLI parsing).</p> Raise <p>Cancelled: A <code>SystemExit</code> based exception noting that the program exits without a traceback, ex. if user hits the escape.</p> Raise <p>InterfaceNotAvailable: Interface failed to init, ex. display not available in GUI. You don't have to check for it when invoking an interface through safe methods <code>run</code> or <code>get_interface</code>.</p>"},{"location":"Mininterface/#mininterface.Mininterface.facet","title":"<code>facet: Facet</code>","text":"<p>Access to the UI <code>facet</code> from the back-end side. (Read <code>Tag.facet</code> to access from the front-end side.)</p> <pre><code>from mininterface import run\nwith run(title='My window title') as m:\n    m.facet.set_title(\"My form title\")\n    m.form({\"My form\": 1})\n</code></pre> <p></p>"},{"location":"Mininterface/#mininterface.Mininterface.env","title":"<code>env: EnvClass | SimpleNamespace = EnvInstance</code>","text":"<p>Parsed arguments from the EnvClass.     Contains whole configuration (previously fetched from CLI and config file).</p> <pre><code>$ program.py --number 10\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    number: int = 3\n    text: str = \"\"\n\nm = run(Env)\nprint(m.env.number)  # 10\n</code></pre>"},{"location":"Mininterface/#mininterface.Mininterface.__enter__","title":"<code>__enter__()</code>","text":"<p>Usage within the with statement makes the program to attempt for the following benefits:</p>"},{"location":"Mininterface/#mininterface.Mininterface.__enter__--continual-window","title":"Continual window","text":"<p>Do not vanish between dialogs (the GUI window stays the same)</p>"},{"location":"Mininterface/#mininterface.Mininterface.__enter__--stdout-redirection","title":"Stdout redirection","text":"<p>Redirects the stdout to a text area instead of a terminal.</p> <pre><code>from mininterface import run\n\nwith run() as m:\n    print(\"This is a printed text\")\n    m.alert(\"Alert text\")\n</code></pre> <p></p>"},{"location":"Mininterface/#mininterface.Mininterface.__enter__--make-the-session-interactive","title":"Make the session interactive","text":"<p>If run from an interactive terminal or if a GUI is used, nothing special happens.</p> <pre><code># $ ./program.py\nwith run() as m:\n    m.ask(\"What number\", int)\n</code></pre> <p></p> <p>However, when run in a non-interactive session with TUI (ex. no display), TextInterface is used which is able to turn it into an interactive one.</p> <pre><code>piped_in = int(sys.stdin.read())\n\nwith run(interface=\"tui\") as m:\n    result = m.ask(\"What number\", int) + piped_in\nprint(result)\n</code></pre> <pre><code>$ echo 2 | ./program.py\nWhat number: 3\n5\n</code></pre> <p>If the <code>with</code> statement is not used, the result is the same as if an interactive session is not available, like in a cron job. In that case, plain Mininterface is used.</p> <pre><code>piped_in = int(sys.stdin.read())\n\nm = run(interface=\"tui\")\nresult = m.ask(\"What number\", int) + piped_in\nprint(result)\n</code></pre> <pre><code>echo 2 | ./program.py\nAsking: What number\n3\n</code></pre>"},{"location":"Mininterface/#mininterface.Mininterface.alert","title":"<code>alert(text)</code>","text":"<p>Prompt the user to confirm the text.</p>"},{"location":"Mininterface/#mininterface.Mininterface.ask","title":"<code>ask(text, annotation=str, validation=None)</code>","text":"<p>Prompt the user to input a value \u2013 text, number, ...</p> <p>By default, it resembles the <code>input()</code> built-in.</p> <pre><code>m = run()  # receives a Mininterface object\nm.ask(\"What's your name?\")  # -&gt; str\n</code></pre> <p>You may specify the type:</p> <pre><code>m = run()  # receives a Mininterface object\nm.ask(\"What's your age?\", int)\n</code></pre> <p></p> <p>The type might be complex. This enforces a list of paths.</p> <pre><code>from mininterface import run\nfrom pathlib import Path\n\nm = run()\nm.ask(\"Enlist input files\", list[Path])\n</code></pre> <p>Also, you can further specify the value with a Tag. This enforces an existing file:</p> <pre><code>from mininterface import run\nfrom mininterface.tag import PathTag\n\nm = run()\nm.ask(\"Give me input file\", PathTag(is_file=True))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The question text.</p> required <code>annotation</code> <code>Type[TagValue] | Tag[TagValue]</code> <p>The return type. <pre><code>from datetime import time\nfrom mininterface import run\n\nm = run()\nm.ask(\"Give me a time\", time)\n</code></pre></p> <code>str</code> <code>validation</code> <code>Iterable[ValidationCallback] | ValidationCallback | None</code> <p>Limit the value. <pre><code>from annotated_types import Gt\nfrom mininterface import run\n\nm = run()\nm.ask(\"Give me a positive number\", int, Gt(0))\n</code></pre></p> <code>None</code> <p>Returns:</p> Type Description <code>TagValue</code> <p>The type from the <code>annotation</code>. By default <code>str</code> but might be int, datetime...</p>"},{"location":"Mininterface/#mininterface.Mininterface.confirm","title":"<code>confirm(text, default=True)</code>","text":"<p>Display confirm box and returns bool.</p> <pre><code>m = run()\nprint(m.confirm(\"Is that alright?\"))  # True/False\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Displayed text.</p> required <code>default</code> <code>bool</code> <p>Focus the button with this value.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the user has chosen the Yes button.</p>"},{"location":"Mininterface/#mininterface.Mininterface.select","title":"<code>select(options, title='', default=None, tips=None, multiple=None, skippable=True, launch=True)</code>","text":"<p>Prompt the user to select. Useful for a menu creation.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>OptionsType[TagValue]</code> <p>You can denote the options in many ways. Either put options in an iterable, or to a dict with keys as labels. You can also use tuples for keys to get a table-like formatting. Use the Enums or nested Tags... See the <code>OptionsType</code> for more details.</p> required <code>title</code> <code>str</code> <p>Form title</p> <code>''</code> <code>default</code> <code>TagValue | OptionsType[TagValue] | None</code> <p>The value of the checked choice.</p> <p><pre><code>m.select({\"one\": 1, \"two\": 2}, default=2)  # returns 2\n</code></pre> </p> <p>If the list is given, this implies multiple choice.</p> <code>None</code> <code>tips</code> <code>OptionsType[TagValue] | None</code> <p>Options to be highlighted. Use the list of choice values to denote which one the user might prefer.</p> <code>None</code> <code>multiple</code> <code>Optional[bool]</code> <p>If True, the user can choose multiple values and we return a list.</p> <code>None</code> <code>skippable</code> <code>bool</code> <p>If there is a single option, choose it directly, without a dialog.</p> <code>True</code> <code>launch</code> <code>bool</code> <p>If the chosen value is a callback, we directly call it and return its return value.</p> <pre><code>def do_cmd1():\n    return \"cmd1\"\n\ndef do_cmd2():\n    return \"cmd2\"\n\nm = run()\nout = m.select({\"Open file...\": do_cmd1, \"Apply filter...\": do_cmd2})\nprint(out)  # 'cmd1' or 'cmd2'\n</code></pre> <code>True</code> <p>Returns:</p> Name Type Description <code>TagValue</code> <code>TagValue | list[TagValue] | Any</code> <p>The chosen value.</p> <code>list</code> <code>TagValue | list[TagValue] | Any</code> <p>If multiple=True, return chosen values.</p> <code>Any</code> <code>TagValue | list[TagValue] | Any</code> <p>If launch=True and the chosen value is a callback, we call it and return its result.</p> <p>Info</p> <p>To tackle a more detailed form, see <code>SelectTag.options</code>.</p>"},{"location":"Mininterface/#mininterface.Mininterface.form","title":"<code>form(form=None, title='', *, submit=True)</code>","text":"<p>Prompt the user to fill up an arbitrary form.</p> <p>Use scalars, enums, enum instances, objects like datetime, Paths or their list.</p> <pre><code>from enum import Enum\nfrom mininterface import run, Tag\n\nclass Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\nm = run()\nout = m.form({\n    \"my_number\": 1,\n    \"my_boolean\": True,\n    \"my_enum\": Color,\n    \"my_tagged\": Tag(\"\", name='Tagged value', description='Long hint'),\n    \"my_path\": Path(\"/tmp\"),\n    \"my_paths\": [Path(\"/tmp\")],\n    \"My enum with default\": Color.BLUE\n})\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>DataClass | Type[DataClass] | FormDict | None</code> <p>We accept a dataclass type, a dataclass instance, a dict or None.</p> <ul> <li> <p>A dataclass type is resolved to a dataclass instance that is returned.</p> </li> <li> <p>A dataclass instance is updated by the form and returned.</p> </li> <li> <p>If dict, we expect a dict of <code>{labels: value}</code>. The form widget infers from the default value type. The dict can be nested, it can contain a subgroup. The value might be a <code>Tag</code> that allows you to add descriptions.</p> </li> </ul> <p>A checkbox example: <code>{\"my label\": Tag(True, \"my description\")}</code></p> <p>The original dict values are updated and a new dict (where all Tags are resolved to their values) is returned.</p> <ul> <li>If None, the <code>self.env</code> is being used as a form, allowing the user to edit whole configuration.     (Previously fetched from CLI and config file.)</li> </ul> <code>None</code> <code>title</code> <code>str</code> <p>Optional form title</p> <code>''</code> <code>submit</code> <code>str | bool</code> <p>Set the submit button text (by default 'Ok') or hide it with False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dataclass</code> <code>FormDict | DataClass | EnvClass</code> <p>If the <code>form</code> is null, the output is <code>self.env</code>.</p> <code>dataclass</code> <code>FormDict | DataClass | EnvClass</code> <p>If the <code>form</code> is a dataclass type or a dataclass instance, the output is the dataclass instance.</p> <code>dict</code> <code>FormDict | DataClass | EnvClass</code> <p>If the <code>form</code> is a dict, the output is another dict.</p> <p>Whereas the original dict stays intact (with the values updated), we return a new raw dict with all values resolved (all <code>Tag</code> objects are resolved to their value).</p> <pre><code>original = {\"my label\": Tag(True, \"my description\")}\noutput = m.form(original)  # Sets the label to False in the dialog\n\n# Original dict was updated\nprint(original[\"my label\"])  # Tag(False, \"my description\")\n\n# Output dict is resolved, contains only raw values\nprint(output[\"my label\"])  # False\n</code></pre> <p>Why this behaviour? You need to do some validation, hence you put <code>Tag</code> objects in the input dict. Then, you just need to work with the values.</p> <pre><code>original = {\"my label\": Tag(True, \"my description\")}\noutput = m.form(original)  # Sets the label to False in the dialog\noutput[\"my_label\"]\n</code></pre> <p>In the case you are willing to re-use the dict, you need not to lose the definitions, hence you end up with accessing via the <code>.val</code>.</p> <pre><code>original = {\"my label\": Tag(True, \"my description\")}\n\nfor i in range(10):\n    m.form(original, f\"Attempt {i}\")\n    print(\"The result\", original[\"my label\"].val)\n</code></pre> <p>Info</p> <p>For minimal installation (<code>pip install mininterface</code> only), using <code>Type[DataClass]</code> like <code>m.form(Env)</code> will end up with <code>Install the missing dependency by running: pip install mininterface[basic]</code>. However using a dataclass instance <code>m.form(Env())</code> will work. A lot of the stuff under the hood is needed to instantaniate a dataclass with all the checks.</p>"},{"location":"Overview/","title":"Overview","text":"<p>Via the run function you get access to the CLI, possibly enriched from the config file. Then, you receive all data as <code>m.env</code> object and dialog methods in a proper UI.</p> <pre><code>graph LR\n    subgraph mininterface\n        run --&gt; GUI\n        run --&gt; TUI\n        run --&gt; WebUI\n        run --&gt; env\n        CLI --&gt; run\n        id1[config file] --&gt; CLI\n    end\n    program --&gt; run\n</code></pre>"},{"location":"Overview/#basic-usage","title":"Basic usage","text":"<p>Use a common dataclass, an argparse <code>ArgumentParser</code>, a Pydantic BaseModel or an attrs model to store the configuration. Wrap it to the run function that returns an interface <code>m</code>. Access the configuration via <code>m.env</code> or use it to prompt the user with methods like <code>m.confirm(\"Is that alright?\")</code>.</p> <p>There are a lot of supported types you can use, not only scalars and well-known objects (<code>Path</code>, <code>datetime</code>), but also functions, iterables (like <code>list[Path]</code>) and union types (like <code>int | None</code>). To do even more advanced things, stick the value to a powerful <code>Tag</code> or its subclasses. Ex. for a validation only, use its <code>Validation alias</code>.</p> <p>At last, use <code>Facet</code> to tackle the interface from the back-end (<code>m</code>) or the front-end (<code>Tag</code>) side.</p>"},{"location":"Overview/#ide-suggestions","title":"IDE suggestions","text":"<p>The immediate benefit is the type suggestions provided by your IDE.</p>"},{"location":"Overview/#dataclass-showcase","title":"Dataclass showcase","text":"<p>Imagine following code:</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    my_paths: list[Path]\n    \"\"\" The user is forced to input Paths. \"\"\"\n\n\n@dataclass\nclass Dialog:\n    my_number: int = 2\n    \"\"\" A number \"\"\"\n</code></pre> <p>Now, accessing the main env will trigger the hint. </p> <p>Calling the form with an empty parameter will trigger editing the main env</p> <p></p> <p>Putting there a dict will return the dict too.</p> <p></p> <p>Putting there a dataclass type causes it to be resolved.</p> <p></p> <p>Should you have a resolved dataclass instance, put it there.</p> <p></p> <p>As you see, its attributes are hinted alongside their description.</p> <p></p> <p>Should the dataclass cannot be easily investigated by the IDE (i.e. a required field), just annotate the output.</p> <p></p>"},{"location":"Overview/#select-showcase","title":"Select showcase","text":"<p>We push an intuitive type inference everywhere. Here is an example with the <code>m.select</code> dialog.</p> <pre><code>from mininterface import run\n\nm = run()\n# x = m.select([1, 2, 3], default=2)  # -&gt; int\n# x = m.select([1, 2, 3], multiple=True)  # -&gt; list[int]\n# x = m.select([1, 2, 3], default=[2])  # -&gt; list[int]\n</code></pre> <p>By default, the inferred type is an <code>int</code>.</p> <p></p> <p>When you flag the selection as multiple or when you submit multiple default values...</p> <p></p> <p>that means your IDE sees a <code>list</code> instead of a single value and you can automatically append to it etc.</p> <p></p>"},{"location":"Overview/#nested-configuration","title":"Nested configuration","text":"<p>You can easily nest the configuration. (See also Tyro Hierarchical Configs.)</p> <p>Just put another dataclass inside the config file:</p> <pre><code>@dataclass\nclass FurtherConfig:\n    token: str\n    host: str = \"example.org\"\n\n@dataclass\nclass Env:\n    further: FurtherConfig\n\n...\nm = run(Env)\nprint(m.env.further.host)  # example.org\n</code></pre> <p>The attributes can by defaulted by CLI:</p> <pre><code>$./program.py --further.host example.net\n</code></pre> <p>And in a YAML config file. Note that you are not obliged to define all the attributes, a subset will do. (Ex. you do not need to specify <code>token</code> too.)</p> <pre><code>further:\n  host: example.com\n</code></pre>"},{"location":"Overview/#bash-completion","title":"Bash completion","text":"<p>Run your program with a bundled <code>mininterface</code> executable to start a tutorial that will install bash completion.</p> <p><code>$ mininterface integrate ./program</code></p> <p></p>"},{"location":"Overview/#system-dialog-toolkit","title":"System dialog toolkit","text":"<p>Mininterface can be used as a standalone dialog layer for sh scripts. See <code>mininterface --help</code>.</p> <pre><code>$ mininterface select one two  # outputs a chosen item\n</code></pre> <p></p>"},{"location":"PathTag/","title":"PathTag","text":""},{"location":"PathTag/#mininterface.tag.PathTag","title":"<code>mininterface.tag.PathTag</code>","text":"<p>Contains a Path or their list. Use this helper object to select files.</p> <p>In the following example, we see that it is not always needed to use this object.</p> <ul> <li>File 1 \u2013 plain detection, button to a file picker appeared.</li> <li>File 2 \u2013 the same.</li> <li>File 3 \u2013 we specified multiple paths can be selected.</li> </ul> <pre><code>from pathlib import Path\nfrom mininterface import run, Tag\nfrom mininterface.tag import PathTag\n\nm = run()\nout = m.form({\n    \"File 1\": Path(\"/tmp\"),\n    \"File 2\": Tag(\"\", annotation=Path),\n    \"File 3\": PathTag([Path(\"/tmp\")], multiple=True),\n})\nprint(out)\n# {'File 1': PosixPath('/tmp'), 'File 2': PosixPath('.')}\n# {'File 3': [PosixPath('/tmp')]}\n</code></pre> <p></p>"},{"location":"PathTag/#mininterface.tag.PathTag.multiple","title":"<code>multiple: Optional[bool] = None</code>","text":"<p>The user can select multiple files.</p>"},{"location":"PathTag/#mininterface.tag.PathTag.exist","title":"<code>exist: Optional[bool] = None</code>","text":"<p>If True, validates that the selected file exists</p>"},{"location":"PathTag/#mininterface.tag.PathTag.is_dir","title":"<code>is_dir: Optional[bool] = None</code>","text":"<p>If True, validates that the selected path is a directory</p>"},{"location":"PathTag/#mininterface.tag.PathTag.is_file","title":"<code>is_file: Optional[bool] = None</code>","text":"<p>If True, validates that the selected path is a file</p>"},{"location":"Prepared-annotations/","title":"Prepared annotations","text":"<p>CLI flags have no effect in the UI. Great for CLI so that the user writes less.</p>"},{"location":"Prepared-annotations/#mininterface.tag.flag.Blank","title":"<code>mininterface.tag.flag.Blank</code>","text":"<p>When left blank, this flag produces True.     Return boolean for True|False.     Return None if the flag is omitted.     Else returns T created from the input value.</p> <p>Note that you can not use 'True' or 'False' for values, as the parameter becomes a bool.</p> <p>Warning</p> <p>Experimental.</p>"},{"location":"Prepared-annotations/#mininterface.tag.flag.BlankTrue","title":"<code>mininterface.tag.flag.BlankTrue = Annotated[list[str] | None, PrimitiveConstructorSpec(nargs='*', metavar='blank=True|BOOL', instance_from_str=_assure_blank_or_bool, is_instance=lambda instance: True, str_from_instance=lambda instance: [instance])]</code>","text":"<p>When left blank, this flag produces True.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>for <code>0/false/off/1/true/on</code> in the parameter</p> <code>True</code> <p>When parameter is left blank.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised on an unknown parameter.</p> <p>Warning</p> <p>Experimental.</p>"},{"location":"Prepared-annotations/#mininterface.tag.flag.Dir","title":"<code>mininterface.tag.flag.Dir = Annotated[Path, PathTag(is_dir=True)]</code>","text":"<p>An existing directory. from mininterface import run from mininterface.tag.flag import Dir</p> <pre><code>@dataclass\nclass Env:\n    my_dir: Dir\n\nm = run(Env)\nm.env.my_dir  # guaranteed to be an existing dir\n</code></pre> <p>Warning</p> <p>EXPERIMENTAL.</p>"},{"location":"Prepared-annotations/#mininterface.tag.flag.File","title":"<code>mininterface.tag.flag.File = Annotated[Path, PathTag(is_file=True)]</code>","text":"<p>An existing file. from mininterface import run from mininterface.tag.flag import File</p> <pre><code>@dataclass\nclass Env:\n    my_file: File\n\nm = run(Env)\nm.env.my_file  # guaranteed to be an existing dir\n</code></pre> <p>Warning</p> <p>EXPERIMENTAL.</p>"},{"location":"SecretTag/","title":"SecretTag","text":""},{"location":"SecretTag/#mininterface.tag.SecretTag","title":"<code>mininterface.tag.SecretTag</code>","text":"<p>Contains a secret value that should be masked in the UI.</p> <pre><code>from mininterface import run, Tag\nfrom mininterface.tag import SecretTag\n\nm = run()\nout = m.form({\n    \"My password\": SecretTag(\"TOKEN\"),\n})\nprint(out)\n# {'My password': 'TOKEN'}\n</code></pre> <p></p>"},{"location":"SecretTag/#mininterface.tag.SecretTag.show_toggle","title":"<code>show_toggle: bool = True</code>","text":"<p>Toggle visibility button (eye icon)</p>"},{"location":"SecretTag/#mininterface.tag.SecretTag.__hash__","title":"<code>__hash__()</code>","text":"<p>Make SecretTag hashable for use with Annotated</p>"},{"location":"SecretTag/#mininterface.tag.SecretTag.toggle_visibility","title":"<code>toggle_visibility()</code>","text":"<p>Toggle the masked state</p>"},{"location":"SecretTag/#mininterface.tag.SecretTag.__repr__","title":"<code>__repr__()</code>","text":"<p>Ensure secrets are not accidentally exposed in logs/repr</p>"},{"location":"SelectTag/","title":"SelectTag","text":""},{"location":"SelectTag/#mininterface.tag.SelectTag","title":"<code>mininterface.tag.SelectTag</code>","text":"<p>Handle options \u2013 radio buttons / select box. The value serves as the initially selected choice. It is constrained to those defined in the <code>options</code> attribute.</p>"},{"location":"SelectTag/#mininterface.tag.SelectTag.options","title":"<code>options: OptionsType | None = None</code>","text":"<p>The possible values.</p> <pre><code>m.form({\"My restrained\": SelectTag(options=(\"one\", \"two\"))})\n</code></pre> <p>You can denote the options in many ways. Either put options in an iterable, or to a dict with keys as a values. You can also you tuples for keys to get a table-like formatting. Use the Enums or nested Tags... See the <code>OptionsType</code> for more details.</p> <p>Here we focus at the <code>SelectTag</code> itself and its <code>Options</code> alias. It can be used to annotate a default value in a dataclass.</p> <p><pre><code>from dataclasses import dataclass\nfrom typing import Annotated\nfrom mininterface import run, Options\nfrom mininterface.tag import SelectTag\n\n@dataclass\nclass Env:\n    foo: Annotated[\"str\", Options(\"one\", \"two\")] = \"one\"\n    # `Options` is an alias for `SelectTag(options=)`\n    #   so the same would be:\n    # foo: Annotated[\"str\", SelectTag(options=(\"one\", \"two\"))] = \"one\"\n\nm = run(Env)\nm.form()  # prompts a dialog\n</code></pre> </p> <p>Tip</p> <p>When dealing with a simple use case, use the mininterface.select dialog.</p>"},{"location":"SelectTag/#mininterface.tag.SelectTag.update","title":"<code>update(ui_value)</code>","text":"<p>ui_value is one of the self.options values</p>"},{"location":"Settings/","title":"Settings","text":""},{"location":"Settings/#ui-settings","title":"UI Settings","text":"<p>The UI behaviour might be modified via an settings object. This can be passed to the run function or defined through a config file. Settings defined in the config file have bigger priority. Every interface has its own settings object.</p>"},{"location":"Settings/#config-file-special-section","title":"Config file special section","text":"<p>In a YAML config file, use a special section 'mininterface' to set up the UI. For example, this stub will enforce your program to use the Tui interface.</p> <pre><code>mininterface:\n    interface: tui\n</code></pre>"},{"location":"Settings/#complete-example","title":"Complete example","text":"<p>Source of <code>program.py</code>, we have one single attribute <code>foo</code>:</p> <pre><code>from typing import Annotated\nfrom dataclasses import dataclass\nfrom mininterface import run, Options\n\n@dataclass\nclass Env:\n    foo: Annotated[\"str\", Options(\"one\", \"two\")] = \"one\"\n\nm = run(Env)\nm.form()\n</code></pre> <p>Source of <code>program.yaml</code> will enforce the comboboxes:</p> <pre><code>number: 5\nmininterface:\n    gui:\n        combobox_since: 1\n</code></pre> <p>The difference when using such configuration file.</p> <p> </p>"},{"location":"Settings/#the-settings-object","title":"The settings object","text":"<pre><code>from mininterface.settings import MininterfaceSettings\n\nopt = MininterfaceSettings()\nrun(settings=opt)\n</code></pre>"},{"location":"Settings/#mininterface.settings.MininterfaceSettings","title":"<code>mininterface.settings.MininterfaceSettings</code>","text":""},{"location":"Settings/#mininterface.settings.MininterfaceSettings.interface","title":"<code>interface: Optional[InterfaceName] = None</code>","text":"<p>Enforce an interface. By default, we choose automatically.</p>"},{"location":"Settings/#guisettings","title":"GuiSettings","text":"<pre><code>from mininterface.settings import MininterfaceSettings, GuiSettings\n\nopt = MininterfaceSettings(gui=GuiSettings(combobox_since=1))\nrun(settings=opt)\n</code></pre>"},{"location":"Settings/#mininterface.settings.GuiSettings","title":"<code>mininterface.settings.GuiSettings</code>","text":""},{"location":"Settings/#mininterface.settings.GuiSettings.combobox_since","title":"<code>combobox_since: int = 10</code>","text":"<p>The threshold to switch from radio buttons to a combobox.</p>"},{"location":"Settings/#mininterface.settings.GuiSettings.radio_select_on_focus","title":"<code>radio_select_on_focus: bool = False</code>","text":"<p>Select the radio button on focus. Ex. when navigating by arrows.</p>"},{"location":"Standalone/","title":"Standalone","text":"<p>When invoked directly, it creates simple GUI dialogs.</p> <pre><code>$ mininterface  --help\nusage: Mininterface [-h] [OPTIONS]\n\nSimple GUI dialog. Outputs the value the user entered.\n\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help              show this help message and exit                                   \u2502\n\u2502 --alert STR             Display the OK dialog with text. (default: '')                    \u2502\n\u2502 --ask STR               Prompt the user to input a text. (default: '')                    \u2502\n\u2502 --ask-number STR        Prompt the user to input a number. Empty input = 0. (default: '') \u2502\n\u2502 --is-yes STR            Display confirm box, focusing yes. (default: '')                  \u2502\n\u2502 --is-no STR             Display confirm box, focusing no. (default: '')                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can fetch a value to i.e. a bash script.</p> <pre><code>$ mininterface  --ask-number \"What's your age?\"  # GUI or TUI window invoked\n18\n</code></pre> <p> </p>"},{"location":"Supported-types/","title":"Supported types","text":"<p>Various types are supported:</p> <ul> <li>scalars</li> <li>functions</li> <li>enums</li> <li>well-known objects (<code>Path</code>, <code>datetime</code>)</li> <li>iterables (like <code>list[Path]</code>)</li> <li>custom classes (somewhat)</li> <li>union types (like <code>int | None</code>)</li> </ul>"},{"location":"Supported-types/#basic-usage","title":"Basic usage","text":""},{"location":"Supported-types/#usage-in-a-dataclass","title":"Usage in a dataclass","text":"<p>Take a look how it works with the variables organized in a dataclass:</p> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\n\nfrom mininterface import run\n\n\n@dataclass\nclass Env:\n    my_number: int = 1\n    \"\"\" A dummy number \"\"\"\n    my_boolean: bool = True\n    \"\"\" A dummy boolean \"\"\"\n    my_conditional_number: int | None = None\n    \"\"\" A number that can be null if left empty \"\"\"\n    my_path: Path = Path(\"/tmp\")\n    \"\"\" A dummy path \"\"\"\n\n\nm = run(Env)  # m.env contains an Env instance\nm.form()  # Prompt a dialog; m.form() without parameter edits m.env\nprint(m.env)\n# Env(my_number=1, my_boolean=True, my_path=PosixPath('/tmp'),\n#  my_point=&lt;__main__.Point object at 0x7ecb5427fdd0&gt;)\n</code></pre> <p></p>"},{"location":"Supported-types/#usage-in-a-dict","title":"Usage in a dict","text":"<p>Variables organized in a dict:</p> <p>Along scalar types, there is (basic) support for common iterables or custom classes.</p> <pre><code>from mininterface import run\n\nclass Point:\n    def __init__(self, i: int):\n        self.i = i\n\n    def __str__(self):\n        return str(self.i)\n\n\nvalues = {\"my_number\": 1,\n          \"my_list\": [1, 2, 3],\n          \"my_point\": Point(10)\n          }\n\nm = run()\nm.form(values)  # Prompt a dialog\nprint(values)  # {'my_number': 2, 'my_list': [2, 3], 'my_point': &lt;__main__.Point object...&gt;}\nprint(values[\"my_point\"].i)  # 100\n</code></pre> <p></p>"},{"location":"Supported-types/#examples","title":"Examples","text":"<p>All the examples need some imports:</p> <pre><code>from dataclasses import dataclass, field\nfrom pathlib import Path\nfrom mininterface import run\n</code></pre>"},{"location":"Supported-types/#scalars","title":"Scalars","text":"<pre><code>@dataclass\nclass Env:\n    my_file: str\n    \"\"\" This is my help text \"\"\"\n\n    my_flag: bool = False\n    \"\"\" My checkbox \"\"\"\n\n    my_number: float = 1.1\n    \"\"\" Any scalar possible \"\"\"\n\nrun(Env).form()\n</code></pre>"},{"location":"Supported-types/#functions","title":"Functions","text":"<p>Will appear as buttons.</p> <pre><code>def my_callback():\n    print(\"I'm here!\")\n\n@dataclass\nclass Env:\n    my_file: Callable = my_callback\n\nrun(Env).form()\n</code></pre> <p>Or use the <code>with</code> statement to redirect the stdout into the mininterface.</p> <pre><code>with run(Env) as m:\n    m.form()\n    m.alert(\"The text 'I'm here' is displayed in the window.\")\n</code></pre> <p>Warning</p> <p>When used in a form like this <code>m.form({'My callback': my_callback)</code>, the value is left intact. It still points to the function. This behaviour might reconsidered and changed. (It might make more sense to change it to the return value instead.)</p>"},{"location":"Supported-types/#enums","title":"Enums","text":"<p>To constraint a value, either pass an enum object or use handy additional type SelectTag that might speed you up a bit.</p>"},{"location":"Supported-types/#well-known-objects","title":"Well-known objects","text":"<p>We've added extra functions for known objects like <code>Path</code> or <code>datetime</code> (file exists check etc.), see <code>Tag</code> subclasses in Custom types section (PathTag, DatetimeTag, ...).</p>"},{"location":"Supported-types/#iterables","title":"Iterables","text":"<pre><code>from pathlib import Path\n\n@dataclass\nclass Env:\n    my_file: list[int] = field(default_factory=lambda: [1, 2, 3])\n    my_paths: list[Path] = field(default_factory=lambda: [])\nrun(Env).form()\n</code></pre>"},{"location":"Supported-types/#union-types","title":"Union types","text":"<p>An enormously useful feature is to let the user not set a variable.</p> <pre><code>@dataclass\nclass Env:\n    my_var: int | None = None\n    \"\"\" Left empty for None \"\"\"\n</code></pre>"},{"location":"Supported-types/#additional","title":"Additional","text":"<p>We've added some other useful custom types that can be imported mostly from <code>mininterface.tag</code>.</p> <ol> <li>Tag subclasses \u2013 The descendants of the <code>Tag</code>, the object for storing values. Normally, you don't need to use or know much about those but they can be helpful when you need to further specify the functionality, such as restricting a <code>Path</code> to directories only (PathTag).</li> <li>Tag aliases \u2013 Userful shortcuts.</li> <li>Prepared annotations \u2013 Useful types to be used for nifty CLI parsing.</li> </ol>"},{"location":"Tag-aliases/","title":"Tag aliases","text":""},{"location":"Tag-aliases/#mininterface.Validation","title":"<code>mininterface.Validation(check)</code>","text":"<p>Alias to <code>Tag(validation=...)</code></p> <pre><code>from mininterface import Tag, Validation\n@dataclass\nclass Env:\n    my_text: Annotated[str, Validation(not_empty) = \"will not be emtpy\"\n\n    # which is an alias for:\n    # my_text: Annotated[str, Tag(validation=not_empty)] = \"will not be emtpy\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>check</code> <code>Callable[[Tag], ValidationResult | tuple[ValidationResult, TagValue]]</code> <p>Callback function.</p> required"},{"location":"Tag-aliases/#mininterface.Options","title":"<code>mininterface.Options(*options)</code>","text":"<p>An alias, see <code>SelectTag.options</code></p> <p>Example: <pre><code>@dataclass\nclass Env:\n    foo: Annotated[\"str\", Options(\"one\", \"two\")] = \"one\"\n</code></pre></p>"},{"location":"Tag/","title":"Tag","text":""},{"location":"Tag/#mininterface.Tag","title":"<code>mininterface.Tag</code>","text":"<p>Wrapper around a value that encapsulates a description, validation etc.</p> <p>Bridge between the input values and a UI widget. The widget is created with the help of this object, then transforms the value back (str to int conversion etc).</p> <p>For dataclasses, use in as an annotation:</p> <pre><code>from mininterface import run\n@dataclass\nclass Env:\n    my_str: Annotated[str, Tag(validation=not_empty)]\n\nm = run(Env)\n</code></pre> <p>For dicts, use it as a value:</p> <pre><code>m.form({\"My string\": Tag(annotation=str, validation=not_empty)})\n</code></pre>"},{"location":"Tag/#mininterface.Tag.val","title":"<code>val: TagValue = None</code>","text":"<p>The value wrapped by Tag. It can be any value.</p> <pre><code>from mininterface import run, Tag\n\ntag = Tag(True, \"This is my boolean\", bool)\nm = run()\nm.form({\"My boolean\": tag})\nprint(tag.val)  # True/False\nprint()\n</code></pre> <p></p> <p>The encapsulated value is <code>True</code>, <code>tag.description</code> is 'This is my boolean', <code>tag.annotation</code> is <code>bool</code> and 'My boolean' is used as <code>tag.label</code>.</p> <p>Tip</p> <p>If the Tag is nested, the info is fetched to the outer Tag. When updated, the inner Tag value updates accordingly.</p> <pre><code>tag = Tag(Tag(True))\n</code></pre>"},{"location":"Tag/#mininterface.Tag.description","title":"<code>description: str = ''</code>","text":"<p>The description displayed in the UI.</p>"},{"location":"Tag/#mininterface.Tag.annotation","title":"<code>annotation: type[TagValue] | None = None</code>","text":"<p>Used for validation (ex. to convert an empty string to None). If not set, will be determined automatically from the val type.</p>"},{"location":"Tag/#mininterface.Tag.validation","title":"<code>validation: Iterable[ValidationCallback] | ValidationCallback | None = None</code>","text":"<p>When the user submits the form, the values are validated (and possibly transformed) with a ValidationCallback function (or several of them). If the validation fails, user is prompted to edit the value.</p> <p>The ValidationResult is either a boolean or an error message. Optionally, you may add a second argument to specify the tag value (to ex. recommend a better value).</p>"},{"location":"Tag/#mininterface.Tag.label","title":"<code>label: str | None = None</code>","text":"<p>Name displayed in the UI. If not set, it is taken from the dict key or the field name.</p> <pre><code>m.form({\"label\": ...})\n</code></pre> <pre><code>@dataclass\nclass Form:\n    my_field: str\nm.form(Form)  # label=my_field\n</code></pre>"},{"location":"Tag/#mininterface.Tag.on_change","title":"<code>on_change: Callable[[Tag], Any] | None = None</code>","text":"<p>Accepts a callback that launches whenever the value changes (if the validation succeeds). The callback runs while the dialog is still running. The return value of the callback is currently not used.</p> <p>In the following example, we alter the heading title according to the chosen value.</p> <pre><code>from mininterface import run\nfrom mininterface.tag import SelectTag\n\ndef callback(tag: Tag):\n    tag.facet.set_title(f\"Value changed to {tag.val}\")\n\nm = run()\nm.facet.set_title(\"Click the checkbox\")\nm.form({\n    \"My choice\": SelectTag(options=[\"one\", \"two\"], on_change=callback)\n})\n</code></pre> <p> </p>"},{"location":"Tag/#mininterface.Tag.facet","title":"<code>facet: Facet</code>","text":"<p>Access to the UI <code>facet</code> from the front-end side. (Read <code>Mininterface.facet</code> to access from the back-end side.)</p> <p>Use the UI facet from within a callback, ex. from a validator.</p> <pre><code>from mininterface import run, Tag\n\ndef my_check(tag: Tag):\n    tag.facet.set_title(\"My form title\")\n    return \"Validation failed\"\n\nwith run(title='My window title') as m:\n    m.form({\"My form\": Tag(1, validation=my_check)})\n</code></pre> <p>This happens when you click ok.</p> <p></p>"},{"location":"Tag/#mininterface.Tag.original_val","title":"<code>original_val: TagValue</code>","text":"<p>Meant to be read only in callbacks. The original value, preceding UI change. Handy while validating.</p> <pre><code>def check(tag.val):\n    if tag.val != tag.original_val:\n        return \"You have to change the value.\"\nm.form({\"number\", Tag(8, validation=check)})\n</code></pre>"},{"location":"Tag/#mininterface.Tag.update","title":"<code>update</code>","text":"<p>Update the tag value with type conversion and checks.</p> <p>UI \u2192 Tag \u2192 the object of origin.</p> <p>Parameters:</p> Name Type Description Default <code>ui_value</code> <code>UiValue | str</code> <p>The value as it has been updated in a UI. Update accordingly the value in the original linked dict/object the mininterface was invoked with.</p> <p>Validates the type and do the transformation. (Ex: Some values might be nulled from \"\".)</p> required <p>bool</p> Type Description <code>bool</code> <p>Whether the value was succesfully changed or whether the revision is needed.</p>"},{"location":"Validation/","title":"Validation","text":"<p>We recommend to use the dataclass and validate with the <code>Annotated</code> keyword. We use a Validation type here.</p> <pre><code>from typing import Annotated\nfrom mininterface.validators import not_empty\nfrom mininterface import Validation\n\n@dataclass\nclass Env:\n    test: Annotated[str, Validation(not_empty)] = \"hello\"\n</code></pre> <p>Under the hood, this is just a <code>Tag</code>.</p> <pre><code>@dataclass\nclass Env:\n    test: Annotated[str, Tag(validation=not_empty)] = \"hello\"\n</code></pre> <p>Why we used it in an Annotated statement? To preserve the date type.</p>"},{"location":"Validation/#mininterface.validators","title":"<code>mininterface.validators</code>","text":"<p>Functions suitable for Tag validation. When the user submits a value whose validation fails, they are prompted to edit the value.</p> <pre><code>m = run()\nmy_dict = m.form({\"my_text\", Tag(\"\", validation=validators.not_empty)})\nmy_dict[\"my_text\"]  # You can be sure the value is not empty here.\n</code></pre> <p>Note that alternatively to this module, you may validate with Pydantic or an attrs model.</p> <pre><code>from pydantic import BaseModel, Field\n\nclass MyModel(BaseModel):\n    restrained: str = Field(default=\"hello\", max_length=5)\n</code></pre> <pre><code>import attr\nfrom attr.validators import max_len\n\n@attr.s\nclass AttrsModel:\n    restrained: str = attr.ib(default=\"hello\", validator=max_len(5))\n</code></pre>"},{"location":"Validation/#mininterface.validators.not_empty","title":"<code>not_empty(tag)</code>","text":"<p>Assures that Tag the user has written a value and did not let the field empty.</p> <pre><code>from mininterface import Tag, validators, run\n\nm = run()\nm.form({\"my_text\": Tag(\"\", validation=validators.not_empty)})\n# User cannot leave the string field empty.\n</code></pre> <p>When submitting an empty value, a warning appears:</p> <p></p> <p>Note that for Path, an empty string is converted to an empty Path('.'), hence '.' too is considered as an empty input and the user is not able to set '.' as a value. This does not seem to me as a bad behaviour as in CLI you clearly see the CWD, whereas in a UI the CWD is not evident.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag</code> required"},{"location":"Validation/#mininterface.validators.limit","title":"<code>limit(maxOrMin=None, max_=None, lt=None, gt=None, transform=False)</code>","text":"<p>Limit a number range or a string length.</p> <p>Either use as <code>limit(maximum)</code> or <code>limit(minimum, maximum)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>maximum</code> <code>int</code> <p><code>limit(maximum)</code> \u2013 from zero (including) to maximum (including)</p> required <code>minimum</code> <code>int</code> <p><code>limit(minimum, maximum)</code> \u2013 From minimum (including) to maximum (including)</p> required <code>lt</code> <code>float | None</code> <p>lesser than</p> <code>None</code> <code>gt</code> <code>float | None</code> <p>greater than</p> <code>None</code> <code>transform</code> <code>bool</code> <p>If the value is not within the limit, transform it to a boundary. <pre><code>from mininterface import run, Tag\nfrom mininterface.validators import limit\n\nm = run()\nm.form({\"my_number\": Tag(2, validation=limit(1, 10, transform=True))})\n# Put there '50' \u2192 transformed to 10 and dialog reappears\n# with 'Value must be between 1 and 10.'\n</code></pre></p> <p></p> <code>False</code>"},{"location":"run/","title":"Run","text":""},{"location":"run/#mininterface.run","title":"<code>mininterface.run(env_or_list=None, ask_on_empty_cli=False, title='', config_file=True, add_verbose=True, ask_for_missing=True, interface=None, args=None, settings=None, **kwargs)</code>","text":"<p>The main access, start here. Wrap your configuration dataclass into <code>run</code> to access the interface. An interface is chosen automatically, with the preference of the graphical one, regressed to a text interface for machines without display. Besides, if given a configuration dataclass, the function enriches it with the CLI commands and possibly with the default from a config file if such exists. It searches the config file in the current working directory, with the program name ending on .yaml, ex: <code>program.py</code> will fetch <code>./program.yaml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env_or_list</code> <code>Type[EnvClass] | list[Type[EnvClass]] | ArgumentParser | None</code> <ul> <li><code>dataclass</code> Dataclass with the configuration. Their values will be modified with the CLI arguments.</li> <li><code>list</code> of dataclasses let you create multiple commands within a single program, each with unique options. You may use Command descendants to be automatically run.</li> <li><code>argparse.ArgumentParser</code> Not as powerful as the <code>dataclass</code> but should you need to try out whether to use the Mininterface instead of the old <code>argparse</code>, this is the way to go.</li> <li><code>None</code> You need just the dialogs, no CLI/config file parsing.</li> </ul> <code>None</code> <code>ask_on_empty_cli</code> <code>bool</code> <p>If program was launched with no arguments (empty CLI), invokes self.form() to edit the fields. (Withdrawn when <code>ask_for_missing</code> happens.) <pre><code>@dataclass\nclass Env:\nnumber: int = 3\ntext: str = \"\"\nm = run(Env, ask_on_empty=True)\n</code></pre></p> <pre><code>$ program.py  #  omitting all parameters\n# Dialog for `number` and `text` appears\n$ program.py --number 3\n# No dialog appears\n</code></pre> <code>False</code> <code>title</code> <code>str</code> <p>The main title. If not set, taken from <code>prog</code> or program name.</p> <code>''</code> <code>config_file</code> <code>Path | str | bool</code> <p>File to load YAML to be merged with the configuration. You do not have to re-define all the settings in the config file, you can choose a few. If set to True (default), we try to find one in the current working dir, whose name stem is the same as the program's. Ex: <code>program.py</code> will search for <code>program.yaml</code>. If False, no config file is used.</p> <code>True</code> <code>add_verbose</code> <code>bool</code> <p>Adds the verbose flag that automatically sets the level to <code>logging.INFO</code> (-v) or <code>logging.DEBUG</code> (-vv).</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\n\nm = run(Env, add_verbose=True)\nlogger.info(\"Info shown\") # needs `-v` or `--verbose`\nlogger.debug(\"Debug not shown\")  # needs `-vv`\n# $ program.py --verbose\n# Info shown\n</code></pre> <pre><code>$ program.py --verbose\nInfo shown\n</code></pre> <code>True</code> <code>ask_for_missing</code> <code>bool</code> <p>If some required fields are missing at startup, we ask for them in a UI instead of program exit.</p> <pre><code>@dataclass\nclass Env:\n    required_number: int\nm = run(Env, ask_for_missing=True)\n</code></pre> <pre><code>$ program.py  # omitting --required-number\n# Dialog for `required_number` appears\n</code></pre> <code>True</code> <code>interface</code> <code>Type[Mininterface] | Literal['gui'] | Literal['tui'] | Literal['text'] | Literal['web'] | None</code> <p>Which interface to prefer. By default, we use the GUI, the fallback is the TUI. You may write \"gui\" or \"tui\" literal or pass a specific Mininterface type, see the full list of possible interfaces. If not set, we look also for an environment variable <code>MININTERFACE_INTERFACE</code> and in the config file.</p> <code>None</code> <code>args</code> <code>Optional[Sequence[str]]</code> <p>Parse arguments from a sequence instead of the command line.</p> <code>None</code> <code>settings</code> <code>Optional[MininterfaceSettings]</code> <p>Default settings. These might be further modified by the 'mininterface' section in the config file.</p> <code>None</code> <p>Kwargs:     The same as for argparse.ArgumentParser.</p> <p>Returns:</p> Type Description <code>Mininterface[EnvClass]</code> <p>An interface, ready to be used.</p> <p>You cay context manager the function by a <code>with</code> statement. The stdout will be redirected to the interface (ex. a GUI window).</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    my_number: int = 4\n\nwith run(Env) as m:\n    print(f\"Your important number is {m.env.my_number}\")\n    boolean = m.confirm(\"Is that alright?\")\n</code></pre> <p> </p>"}]}