{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mininterface \u2013 access to GUI, TUI, CLI and config files","text":"<p>Write the program core, do not bother with the input/output.</p> <p> </p> <p>Check out the code, which is surprisingly short, that displays such a window or its textual fallback.</p> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    \"\"\"Set of options.\"\"\"\n\n    test: bool = False\n    \"\"\" My testing flag \"\"\"\n\n    important_number: int = 4\n    \"\"\" This number is very important \"\"\"\n\nif __name__ == \"__main__\":\n    env = run(Env, prog=\"My application\").env\n    # Attributes are suggested by the IDE\n    # along with the hint text 'This number is very important'.\n    print(env.important_number)\n</code></pre>"},{"location":"#you-got-cli","title":"You got CLI","text":"<p>It was all the code you need. No lengthy blocks of code imposed by an external dependency. Besides the GUI/TUI, you receive powerful YAML-configurable CLI parsing.</p> <pre><code>$ ./hello.py\nusage: My application [-h] [--test | --no-test] [--important-number INT]\n\nSet of options.\n\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help              show this help message and exit            \u2502\n\u2502 --test, --no-test       My testing flag (default: False)           \u2502\n\u2502 --important-number INT  This number is very important (default: 4) \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#you-got-config-file-management","title":"You got config file management","text":"<p>Loading config file is a piece of cake. Alongside <code>program.py</code>, put <code>program.yaml</code> and put there some of the arguments. They are seamlessly taken as defaults.</p> <pre><code>important_number: 555\n</code></pre>"},{"location":"#you-got-dialogues","title":"You got dialogues","text":"<p>Check out several useful methods to handle user dialogues. Here we bound the interface to a <code>with</code> statement that redirects stdout directly to the window.</p> <pre><code>with run(Env) as m:\n    print(f\"Your important number is {m.env.important_number}\")\n    boolean = m.is_yes(\"Is that alright?\")\n</code></pre> <p> </p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Mininterface \u2013 GUI, TUI, CLI and config</li> <li>Background</li> <li>Installation</li> <li>Docs</li> <li>Examples</li> </ul>"},{"location":"#background","title":"Background","text":"<p>Wrapper between the tyro <code>argparse</code> replacement and tkinter_form that converts dicts into a GUI.</p> <p>Writing a small and useful program might be a task that takes fifteen minutes. Adding a CLI to specify the parameters is not so much overhead. But building a simple GUI around it? HOURS! Hours spent on researching GUI libraries, wondering why the Python desktop app ecosystem lags so far behind the web world. All you need is a few input fields validated through a clickable window... You do not deserve to add hundred of lines of the code just to define some editable fields. <code>Mininterface</code> is here to help.</p> <p>The config variables needed by your program are kept in cozy dataclasses. Write less! The syntax of tyro does not require any overhead (as its <code>argparse</code> alternatives do). You just annotate a class attribute, append a simple docstring and get a fully functional application: * Call it as <code>program.py --help</code> to display full help. * Use any flag in CLI: <code>program.py --test</code>  causes <code>env.test</code> be set to <code>True</code>. * The main benefit: Launch it without parameters as <code>program.py</code> to get a full working window with all the flags ready to be edited. * Running on a remote machine? Automatic regression to the text interface.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with a single command from PyPi.</p> <pre><code>pip install mininterface\n</code></pre>"},{"location":"#docs","title":"Docs","text":"<p>See the docs at https://cz-nic.github.io/mininterface/.</p>"},{"location":"#examples","title":"Examples","text":"<p>This is a complex example.</p> <pre><code>from typing import Annotated\nfrom dataclasses import dataclass\nfrom mininterface.validators import not_empty\nfrom mininterface import run, Tag, Validation\n\n@dataclass\nclass NestedEnv:\n  another_number: int = 7\n  \"\"\" This field is nested \"\"\"\n\n@dataclass\nclass Env:\n  nested_config: NestedEnv\n\n  my_number: int = 5\n  \"\"\" This is just a dummy number \"\"\"\n\n  my_string: str = \"Hello\"\n  \"\"\" A dummy string \"\"\"\n\n  my_flag: bool = False\n  \"\"\" Checkbox test \"\"\"\n\n  my_validated: Annotated[str, Validation(not_empty)] = \"hello\"\n  \"\"\" A validated field \"\"\"\n\nm = run(Env, title=\"My program\")\n# See some values\nprint(m.env.nested_config.another_number)  # 7\nprint(m.env)\n# Env(nested_config=NestedEnv(another_number=7), my_number=5, my_string='Hello', my_flag=False, my_validated='hello')\n\n# Edit values in a dialog\nm.form()\n</code></pre>"},{"location":"Mininterface/","title":"Mininterface","text":"<p>               Bases: <code>Generic[EnvClass]</code></p> <p>The base interface. You get one through <code>mininterface.run</code> which fills CLI arguments and config file to <code>mininterface.env</code> or you can create one directly (without benefiting from the CLI parsing).</p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.env","title":"<code>env: EnvClass = _env or SimpleNamespace()</code>  <code>instance-attribute</code>","text":"<p>Parsed arguments, fetched from cli     Contains whole configuration (previously fetched from CLI and config file).</p> <pre><code>$ program.py --number 10\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom mininterface import run\n\n@dataclass\nclass Env:\n    number: int = 3\n    text: str = \"\"\n\nm = run(Env)\nprint(m.env.number)  # 10\n</code></pre>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.__enter__","title":"<code>__enter__()</code>","text":"<p>When used in the with statement, the GUI window does not vanish between dialogs and it redirects the stdout to a text area.</p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.alert","title":"<code>alert(text)</code>","text":"<p>Prompt the user to confirm the text.</p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.ask","title":"<code>ask(text)</code>","text":"<p>Prompt the user to input a text.</p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.ask_number","title":"<code>ask_number(text)</code>","text":"<p>Prompt the user to input a number. Empty input = 0.</p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.form","title":"<code>form(form=None, title='')</code>","text":"<p>Prompt the user to fill up whole form.</p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>FormDictOrEnv | None</code> <p>Dict of <code>{labels: default value}</code>. The form widget infers from the default value type. The dict can be nested, it can contain a subgroup. The default value might be <code>mininterface.Tag</code> that allows you to add descriptions. If None, the <code>self.env</code> is being used as a form, allowing the user to edit whole configuration.     (Previously fetched from CLI and config file.) A checkbox example: <code>{\"my label\": Tag(True, \"my description\")}</code></p> <code>None</code> <code>title</code> <code>str</code> <p>Optional form title</p> <code>''</code>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.is_yes","title":"<code>is_yes(text)</code>","text":"<p>Display confirm box, focusing yes.</p> <pre><code>m = run()\nprint(m.is_yes(\"Is that alright?\"))  # True/False\n</code></pre> <p></p>"},{"location":"Mininterface/#mininterface.mininterface.Mininterface.is_no","title":"<code>is_no(text)</code>","text":"<p>Display confirm box, focusing no.</p>"},{"location":"Mininterface/#all-possible-interfaces","title":"All possible interfaces","text":"<p>Several interfaces exist:</p> <ul> <li><code>Mininterface</code> \u2013 The base interface. Does not require any user input and hence is suitable for headless testing.</li> <li><code>GuiInterface</code> \u2013 A tkinter window.</li> <li><code>TuiInterface</code> \u2013 An interactive terminal.</li> <li><code>TextualInterface</code> \u2013 If textual installed, rich interface is used.</li> <li><code>TextInterface</code> \u2013 Plain text only interface with no dependency as a fallback.</li> <li><code>ReplInterface</code> \u2013 A debug terminal. Invokes a breakpoint after every dialog.</li> </ul> <p>Normally, you get an interface through mininterface.run but if you do not wish to parse CLI and config file, you can invoke one directly.</p> <pre><code>with TuiInterface(\"My program\") as m:\n    number = m.ask_number(\"Returns number\")\n</code></pre>"},{"location":"Overview/","title":"Overview","text":""},{"location":"Overview/#basic-usage","title":"Basic usage","text":"<p>Use a common dataclass, a Pydantic BaseModel or an attrs model to store the configuration. Wrap it to the run method that returns an interface <code>m</code>. Access the configuration via <code>m.env</code> or use it to prompt the user <code>m.is_yes(\"Is that alright?\")</code>. To do any advanced things, stick the value to a powerful <code>Tag</code>. For a validation only, use its <code>Validation alias</code>.</p>"},{"location":"Overview/#supported-types","title":"Supported types","text":"<p>Various types are supported: scalars, functions, well-known objects (Path), iterables, custom classes.</p> <p>Take a look how it works with the variables organized in a dataclass:</p> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\n\nfrom mininterface import run\n\n\n@dataclass\nclass Env:\n    my_number: int = 1\n    \"\"\" A dummy number \"\"\"\n    my_boolean: bool = True\n    \"\"\" A dummy boolean \"\"\"\n    my_path: Path = Path(\"/tmp\")\n    \"\"\" A dummy path \"\"\"\n\n\nm = run(Env)  # m.env contains an Env instance\nm.form()  # Prompt a dialog; m.form() without parameter edits m.env\nprint(m.env)\n# Env(my_number=1, my_boolean=True, my_path=PosixPath('/tmp'),\n#  my_point=&lt;__main__.Point object at 0x7ecb5427fdd0&gt;)\n</code></pre> <p></p> <p>Variables organized in a dict:</p> <p>Along scalar types, there is (basic) support for common iterables or custom classes.</p> <pre><code>from mininterface import run\n\nclass Point:\n    def __init__(self, i: int):\n        self.i = i\n\n    def __str__(self):\n        return str(self.i)\n\n\nvalues = {\"my_number\": 1,\n          \"my_list\": [1, 2, 3],\n          \"my_point\": Point(10)\n          }\n\nm = run()\nm.form(values)  # Prompt a dialog\nprint(values)  # {'my_number': 2, 'my_list': [2, 3], 'my_point': &lt;__main__.Point object...&gt;}\nprint(values[\"my_point\"].i)  # 100\n</code></pre> <p></p>"},{"location":"Overview/#nested-configuration","title":"Nested configuration","text":"<p>You can easily nest the configuration. (See also Tyro Hierarchical Configs).</p> <p>Just put another dataclass inside the config file:</p> <pre><code>@dataclass\nclass FurtherConfig:\n    token: str\n    host: str = \"example.org\"\n\n@dataclass\nclass Config:\n    further: FurtherConfig\n\n...\nprint(config.further.host)  # example.org\n</code></pre> <p>A subset might be defaulted in YAML:</p> <pre><code>further:\n  host: example.com\n</code></pre> <p>Or by CLI:</p> <pre><code>$./program.py --further.host example.net\n</code></pre>"},{"location":"Standalone/","title":"Standalone","text":"<p>When invoked directly, it creates simple GUI dialogs.</p> <pre><code>$ mininterface  --help\nusage: Mininterface [-h] [OPTIONS]\n\nSimple GUI dialog. Outputs the value the user entered.\n\n\u256d\u2500 options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 -h, --help              show this help message and exit                                   \u2502\n\u2502 --alert STR             Display the OK dialog with text. (default: '')                    \u2502\n\u2502 --ask STR               Prompt the user to input a text. (default: '')                    \u2502\n\u2502 --ask-number STR        Prompt the user to input a number. Empty input = 0. (default: '') \u2502\n\u2502 --is-yes STR            Display confirm box, focusing yes. (default: '')                  \u2502\n\u2502 --is-no STR             Display confirm box, focusing no. (default: '')                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can fetch a value to i.e. a bash script.</p> <pre><code>$ mininterface  --ask-number \"What's your age?\"  # GUI window invoked\n18\n</code></pre>"},{"location":"Tag/","title":"Tag","text":"<p>Wrapper around a value that encapsulates a description, validation etc. When you provide a value to an interface, you may instead use this object.</p> <p>Bridge between the input values and a UI widget. The widget is created with the help of this object, then transforms the value back (str to int conversion etc).</p>"},{"location":"Tag/#mininterface.Tag.val","title":"<code>val: TagValue = None</code>","text":"<p>The value wrapped by Tag.</p> <pre><code>from mininterface import run, Tag\n\ntag = Tag(True, \"This is my boolean\", bool)\nm = run()\nm.form({\"My boolean\": tag})\nprint(tag.val)  # True/False\nprint()\n</code></pre> <p></p> <p>The encapsulated value is <code>True</code>, <code>tag.description</code> is 'This is my boolean', <code>tag.annotation</code> is <code>bool</code> and 'My boolean' is used as <code>tag.name</code>.</p>"},{"location":"Tag/#mininterface.Tag.description","title":"<code>description: str = ''</code>","text":"<p>The description displayed in the UI.</p>"},{"location":"Tag/#mininterface.Tag.annotation","title":"<code>annotation: type | None = None</code>","text":"<p>Used for validation (ex. to convert an empty string to None). If not set, will be determined automatically from the val type.</p>"},{"location":"Tag/#mininterface.Tag.name","title":"<code>name: str | None = None</code>","text":"<p>Name displayed in the UI.</p>"},{"location":"Tag/#mininterface.Tag.validation","title":"<code>validation: Callable[[Tag], ValidationResult | tuple[ValidationResult, TagValue]] | None = None</code>","text":"<p>When the user submits the form, the values are validated (and possibly transformed) with a callback function.     If the validation fails, user is prompted to edit the value.     Return True if validation succeeded or False or an error message when it failed.</p> <p>ValidationResult is a bool or the error message (that implicitly means it has failed).</p> <pre><code>def check(tag: Tag):\n    if tag.val &lt; 10:\n        return \"The value must be at least 10\"\nm.form({\"number\", Tag(12, validation=check)})\n</code></pre> <p>Either use a custom callback function or mininterface.validators.</p> <pre><code>from mininterface.validators import not_empty\nm.form({\"number\", Tag(\"\", validation=not_empty)})\n# User cannot leave the field empty.\n</code></pre> <p>You may use the validation in a type annotation. <pre><code>from mininterface import Tag, Validation\n@dataclass\nclass Env:\n    my_text: Annotated[str, Validation(not_empty) = \"will not be emtpy\"\n\n    # which is an alias for:\n    # my_text: Annotated[str, Tag(validation=not_empty)] = \"will not be emtpy\"\n</code></pre></p> <p>NOTE Undocumented feature, we can return tuple [ValidationResult, FieldValue] to set the self.val.</p>"},{"location":"Tag/#mininterface.Tag.choices","title":"<code>choices: list[str] | None = None</code>","text":"<p>TODO</p>"},{"location":"Tag/#mininterface.Tag.original_val","title":"<code>original_val = None</code>","text":"<p>Read only. The original value, preceding UI change. Handy while validating.</p> <pre><code>def check(tag.val):\n    if tag.val != tag.original_val:\n        return \"You have to change the value.\"\nm.form({\"number\", Tag(8, validation=check)})\n</code></pre>"},{"location":"Tag/#mininterface.Tag.error_text","title":"<code>error_text = None</code>","text":"<p>Read only. Error text if type check or validation fail and the UI has to be revised</p>"},{"location":"Tag/#mininterface.Tag.update","title":"<code>update</code>","text":"<p>UI value \u2192 Tag value \u2192 original value. (With type conversion and checks.)</p> <p>Parameters:</p> Name Type Description Default <code>ui_value</code> <code>TagValue</code> <p>The value as it has been updated in a UI. Update accordingly the value in the original linked dict/object the mininterface was invoked with.</p> <p>Validates the type and do the transformation. (Ex: Some values might be nulled from \"\".)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool, whether the value is alright or whether the revision is needed.</p>"},{"location":"Tag/#helper-types","title":"Helper types","text":""},{"location":"Tag/#mininterface.tag.ValidationResult","title":"<code>ValidationResult = bool | ErrorMessage</code>","text":"<p>Callback validation result is either boolean or an error message.</p>"},{"location":"Tag/#mininterface.tag.ErrorMessage","title":"<code>ErrorMessage = TypeVar('ErrorMessage')</code>","text":"<p>A string, callback validation error message.</p>"},{"location":"Tag/#mininterface.tag.TagValue","title":"<code>TagValue = TypeVar('TagValue')</code>","text":"<p>Any value.</p>"},{"location":"Validation/","title":"Validation","text":"<p>We recommend to use the dataclass and validate with the <code>Annotated</code> keyword.</p> <pre><code>from typing import Annotated\nfrom mininterface.validators import not_empty\nfrom mininterface import Validation\n\n@dataclass\nclass Env:\n    test: Annotated[str, Validation(not_empty)] = \"hello\"\n</code></pre> <p>Under the hood, this is just a <code>Tag</code>.</p> <pre><code>@dataclass\nclass Env:\n    test: Annotated[str, Tag(validation=not_empty)] = \"hello\"\n</code></pre> <p>Why we used it in an Annotated statement? To preserve the date type.</p> <pre><code>@dataclass\nclass Env:\n    my_string: Tag = Tag(\"hello\", validation=not_empty)\n\nm = run(Env)\nprint(type(m.env.my_string))  # Tag\nprint(m.env.my_string.val)  # hello\n</code></pre>"},{"location":"Validation/#validation-alias","title":"<code>Validation</code> alias","text":"<p>Alias to <code>Tag(validation=...)</code></p> <pre><code>from mininterface import Tag, Validation\n@dataclass\nclass Env:\n    my_text: Annotated[str, Validation(not_empty) = \"will not be emtpy\"\n\n    # which is an alias for:\n    # my_text: Annotated[str, Tag(validation=not_empty)] = \"will not be emtpy\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>check</code> <code>Callable[[Tag], ValidationResult | tuple[ValidationResult, TagValue]]</code> <p>Callback function.</p> required"},{"location":"Validation/#validators","title":"validators","text":"<p>Functions suitable for Tag validation. When the user submits a value whose validation fails, they are prompted to edit the value.</p> <pre><code>m = run()\nmy_dict = m.form({\"my_text\", Tag(\"\", validation=validators.not_empty)})\nmy_dict[\"my_text\"]  # You can be sure the value is not empty here.\n</code></pre> <p>Note that alternatively to this module, you may validate with Pydantic or an attrs model.</p> <pre><code>from pydantic import BaseModel, Field\n\nclass MyModel(BaseModel):\n    restrained: str = Field(default=\"hello\", max_length=5)\n</code></pre> <pre><code>import attr\nfrom attr.validators import max_len\n\n@attr.s\nclass AttrsModel:\n    restrained: str = attr.ib(default=\"hello\", validator=max_len(5))\n</code></pre>"},{"location":"Validation/#mininterface.validators.not_empty","title":"<code>not_empty(tag)</code>","text":"<p>Assures that Tag the user has written a value and did not let the field empty.</p> <pre><code>from mininterface import Tag, validators, run\n\nm = run()\nm.form({\"my_text\": Tag(\"\", validation=validators.not_empty)})\n# User cannot leave the string field empty.\n</code></pre> <p>When submitting an empty value, a warning appears:</p> <p></p> <p>Note that for Path, an empty string is converted to an empty Path('.'), hence '.' too is considered as an empty input and the user is not able to set '.' as a value. This does not seem to me as a bad behaviour as in CLI you clearly see the CWD, whereas in a UI the CWD is not evident.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag</code> required"},{"location":"Validation/#mininterface.validators.limit","title":"<code>limit(maxOrMin=None, max_=None, lt=None, gt=None, transform=False)</code>","text":"<p>Limit a number range or a string length.</p> <p>Either use as <code>limit(maximum)</code> or <code>limit(minimum, maximum)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>maximum</code> <code>int</code> <p><code>limit(maximum)</code> \u2013 from zero (including) to maximum (including)</p> required <code>minimum</code> <code>int</code> <p><code>limit(minimum, maximum)</code> \u2013 From minimum (including) to maximum (including)</p> required <code>lt</code> <code>float | None</code> <p>lesser than</p> <code>None</code> <code>gt</code> <code>float | None</code> <p>greater than</p> <code>None</code> <code>transform</code> <p>If the value is not withing the limit, transform it to a boundary. <pre><code>from mininterface import run, Tag\nfrom mininterface.validators import limit\n\nm = run()\nm.form({\"my_number\": Tag(2, validation=limit(1, 10, transform=True))})\n# Put there '50' \u2192 transformed to 10 and dialog reappears\n# with 'Value must be between 1 and 10.'\n</code></pre></p> <p></p> <code>False</code>"},{"location":"run/","title":"Run","text":"<p>The main access, start here. Wrap your configuration dataclass into <code>run</code> to access the interface. An interface is chosen automatically, with the preference of the graphical one, regressed to a text interface for machines without display. Besides, if given a configuration dataclass, the function enriches it with the CLI commands and possibly with the default from a config file if such exists. It searches the config file in the current working directory, with the program name ending on .yaml, ex: <code>program.py</code> will fetch <code>./program.yaml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>env_class</code> <code>Type[EnvClass] | None</code> <p>Dataclass with the configuration. Their values will be modified with the CLI arguments.</p> <code>None</code> <code>ask_on_empty_cli</code> <code>bool</code> <p>If program was launched with no arguments (empty CLI), invokes self.form() to edit the fields. (Withdrawn when <code>ask_for_missing</code> happens.) <pre><code>@dataclass\nclass Env:\nnumber: int = 3\ntext: str = \"\"\nm = run(Env, ask_on_empty=True)\n</code></pre></p> <pre><code>$ program.py  #  omitting all parameters\n# Dialog for `number` and `text` appears\n$ program.py --number 3\n# No dialog appears\n</code></pre> <code>False</code> <code>title</code> <code>str</code> <p>The main title. If not set, taken from <code>prog</code> or program name.</p> <code>''</code> <code>config_file</code> <code>Path | str | bool</code> <p>File to load YAML to be merged with the configuration. You do not have to re-define all the settings in the config file, you can choose a few. If set to True (default), we try to find one in the current working dir, whose name stem is the same as the program's. Ex: <code>program.py</code> will search for <code>program.yaml</code>. If False, no config file is used.</p> <code>True</code> <code>add_verbosity</code> <code>bool</code> <p>Adds the verbose flag that automatically sets the level to <code>logging.INFO</code> (-v) or <code>logging.DEBUG</code> (-vv).</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\n\nm = run(Env, add_verbosity=True)\nlogger.info(\"Info shown\") # needs `-v` or `--verbose`\nlogger.debug(\"Debug not shown\")  # needs `-vv`\n# $ program.py --verbose\n# Info shown\n</code></pre> <pre><code>$ program.py --verbose\nInfo shown\n</code></pre> <code>True</code> <code>ask_for_missing</code> <code>bool</code> <p>If some required fields are missing at startup, we ask for them in a UI instead of program exit.</p> <pre><code>@dataclass\nclass Env:\nrequired_number: int\nm = run(Env, ask_for_missing=True)\n</code></pre> <pre><code>$ program.py  # omitting --required-number\n# Dialog for `required_number` appears\n</code></pre> <code>True</code> <code>interface</code> <code>Type[Mininterface]</code> <p>Which interface to prefer. By default, we use the GUI, the fallback is the TUI. See the full list of possible interfaces.</p> <code>GuiInterface or TuiInterface</code> Kwargs <p>The same as for argparse.ArgumentParser.</p> <p>Returns:</p> Type Description <code>Mininterface[EnvClass]</code> <p>An interface, ready to be used.</p> <p>You cay context manager the function by a <code>with</code> statement. The stdout will be redirected to the interface (ex. a GUI window). TODO add wrap example</p> <p>Undocumented experimental: The <code>env_class</code> may be a function as well. We invoke its parameters. However, as Mininterface.env stores the output of the function instead of the Argparse namespace, methods like <code>Mininterface.form(None)</code> (to ask for editing the env values) will work unpredictibly. Also, the config file seems to be fetched only for positional (missing) parameters, and ignored for keyword (filled) parameters. It seems to be this is the tyro's deal and hence it might start working any time. If not, we might help it this way:     <code>if isinstance(config, FunctionType): config = lambda: config(**kwargs[\"default\"])</code></p> <p>Undocumented experimental: <code>default</code> keyword argument for tyro may serve for default values instead of a config file.</p>"}]}